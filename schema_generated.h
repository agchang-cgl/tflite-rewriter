// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct CustomQuantization;
struct CustomQuantizationBuilder;
struct CustomQuantizationT;

struct QuantizationParameters;
struct QuantizationParametersBuilder;
struct QuantizationParametersT;

struct Tensor;
struct TensorBuilder;
struct TensorT;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;
struct Conv2DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsBuilder;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsBuilder;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsBuilder;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsBuilder;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsBuilder;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsBuilder;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsBuilder;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsBuilder;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsBuilder;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsBuilder;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsBuilder;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsBuilder;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsBuilder;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsBuilder;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsBuilder;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsBuilder;
struct LSTMOptionsT;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsBuilder;
struct UnidirectionalSequenceLSTMOptionsT;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsBuilder;
struct BidirectionalSequenceLSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsBuilder;
struct ResizeBilinearOptionsT;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsBuilder;
struct ResizeNearestNeighborOptionsT;

struct CallOptions;
struct CallOptionsBuilder;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsBuilder;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsBuilder;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsBuilder;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsBuilder;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsBuilder;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsBuilder;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsBuilder;
struct SpaceToDepthOptionsT;

struct SubOptions;
struct SubOptionsBuilder;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsBuilder;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsBuilder;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsBuilder;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsBuilder;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsBuilder;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsBuilder;
struct ExpOptionsT;

struct ReducerOptions;
struct ReducerOptionsBuilder;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsBuilder;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsBuilder;
struct SplitOptionsT;

struct SplitVOptions;
struct SplitVOptionsBuilder;
struct SplitVOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsBuilder;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsBuilder;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsBuilder;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsBuilder;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsBuilder;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsBuilder;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsBuilder;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsBuilder;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsBuilder;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsBuilder;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsBuilder;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsBuilder;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsBuilder;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsBuilder;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsBuilder;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsBuilder;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsBuilder;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsBuilder;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsBuilder;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsBuilder;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsBuilder;
struct ShapeOptionsT;

struct PowOptions;
struct PowOptionsBuilder;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsBuilder;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsBuilder;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsBuilder;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsBuilder;
struct OneHotOptionsT;

struct AbsOptions;
struct AbsOptionsBuilder;
struct AbsOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsBuilder;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsBuilder;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsBuilder;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsBuilder;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsBuilder;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsBuilder;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsBuilder;
struct FillOptionsT;

struct FloorModOptions;
struct FloorModOptionsBuilder;
struct FloorModOptionsT;

struct RangeOptions;
struct RangeOptionsBuilder;
struct RangeOptionsT;

struct LeakyReluOptions;
struct LeakyReluOptionsBuilder;
struct LeakyReluOptionsT;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsBuilder;
struct SquaredDifferenceOptionsT;

struct MirrorPadOptions;
struct MirrorPadOptionsBuilder;
struct MirrorPadOptionsT;

struct OperatorCode;
struct OperatorCodeBuilder;
struct OperatorCodeT;

struct Operator;
struct OperatorBuilder;
struct OperatorT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct Model;
struct ModelBuilder;
struct ModelT;

enum TensorType {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_INT8
};

inline const TensorType (&EnumValuesTensorType())[10] {
  static const TensorType values[] = {
    TensorType_FLOAT32,
    TensorType_FLOAT16,
    TensorType_INT32,
    TensorType_UINT8,
    TensorType_INT64,
    TensorType_STRING,
    TensorType_BOOL,
    TensorType_INT16,
    TensorType_COMPLEX64,
    TensorType_INT8
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[11] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
  static const QuantizationDetails values[] = {
    QuantizationDetails_NONE,
    QuantizationDetails_CustomQuantization
  };
  return values;
}

inline const char * const *EnumNamesQuantizationDetails() {
  static const char * const names[3] = {
    "NONE",
    "CustomQuantization",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
  if (flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template<typename T> struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsTraits<tflite::CustomQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

struct QuantizationDetailsUnion {
  QuantizationDetails type;
  void *value;

  QuantizationDetailsUnion() : type(QuantizationDetails_NONE), value(nullptr) {}
  QuantizationDetailsUnion(QuantizationDetailsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(QuantizationDetails_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  QuantizationDetailsUnion(const QuantizationDetailsUnion &);
  QuantizationDetailsUnion &operator=(const QuantizationDetailsUnion &u)
    { QuantizationDetailsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  QuantizationDetailsUnion &operator=(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~QuantizationDetailsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = QuantizationDetailsTraits<typename RT::TableType>::enum_value;
    if (type != QuantizationDetails_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::CustomQuantizationT *AsCustomQuantization() {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<tflite::CustomQuantizationT *>(value) : nullptr;
  }
  const tflite::CustomQuantizationT *AsCustomQuantization() const {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<const tflite::CustomQuantizationT *>(value) : nullptr;
  }
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_SPLIT_V
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[102] {
  static const BuiltinOperator values[] = {
    BuiltinOperator_ADD,
    BuiltinOperator_AVERAGE_POOL_2D,
    BuiltinOperator_CONCATENATION,
    BuiltinOperator_CONV_2D,
    BuiltinOperator_DEPTHWISE_CONV_2D,
    BuiltinOperator_DEQUANTIZE,
    BuiltinOperator_EMBEDDING_LOOKUP,
    BuiltinOperator_FLOOR,
    BuiltinOperator_FULLY_CONNECTED,
    BuiltinOperator_HASHTABLE_LOOKUP,
    BuiltinOperator_L2_NORMALIZATION,
    BuiltinOperator_L2_POOL_2D,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
    BuiltinOperator_LOGISTIC,
    BuiltinOperator_LSH_PROJECTION,
    BuiltinOperator_LSTM,
    BuiltinOperator_MAX_POOL_2D,
    BuiltinOperator_MUL,
    BuiltinOperator_RELU,
    BuiltinOperator_RELU_N1_TO_1,
    BuiltinOperator_RELU6,
    BuiltinOperator_RESHAPE,
    BuiltinOperator_RESIZE_BILINEAR,
    BuiltinOperator_RNN,
    BuiltinOperator_SOFTMAX,
    BuiltinOperator_SPACE_TO_DEPTH,
    BuiltinOperator_SVDF,
    BuiltinOperator_TANH,
    BuiltinOperator_CONCAT_EMBEDDINGS,
    BuiltinOperator_SKIP_GRAM,
    BuiltinOperator_CALL,
    BuiltinOperator_CUSTOM,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
    BuiltinOperator_PAD,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_GATHER,
    BuiltinOperator_BATCH_TO_SPACE_ND,
    BuiltinOperator_SPACE_TO_BATCH_ND,
    BuiltinOperator_TRANSPOSE,
    BuiltinOperator_MEAN,
    BuiltinOperator_SUB,
    BuiltinOperator_DIV,
    BuiltinOperator_SQUEEZE,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_STRIDED_SLICE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_EXP,
    BuiltinOperator_TOPK_V2,
    BuiltinOperator_SPLIT,
    BuiltinOperator_LOG_SOFTMAX,
    BuiltinOperator_DELEGATE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_CAST,
    BuiltinOperator_PRELU,
    BuiltinOperator_MAXIMUM,
    BuiltinOperator_ARG_MAX,
    BuiltinOperator_MINIMUM,
    BuiltinOperator_LESS,
    BuiltinOperator_NEG,
    BuiltinOperator_PADV2,
    BuiltinOperator_GREATER,
    BuiltinOperator_GREATER_EQUAL,
    BuiltinOperator_LESS_EQUAL,
    BuiltinOperator_SELECT,
    BuiltinOperator_SLICE,
    BuiltinOperator_SIN,
    BuiltinOperator_TRANSPOSE_CONV,
    BuiltinOperator_SPARSE_TO_DENSE,
    BuiltinOperator_TILE,
    BuiltinOperator_EXPAND_DIMS,
    BuiltinOperator_EQUAL,
    BuiltinOperator_NOT_EQUAL,
    BuiltinOperator_LOG,
    BuiltinOperator_SUM,
    BuiltinOperator_SQRT,
    BuiltinOperator_RSQRT,
    BuiltinOperator_SHAPE,
    BuiltinOperator_POW,
    BuiltinOperator_ARG_MIN,
    BuiltinOperator_FAKE_QUANT,
    BuiltinOperator_REDUCE_PROD,
    BuiltinOperator_REDUCE_MAX,
    BuiltinOperator_PACK,
    BuiltinOperator_LOGICAL_OR,
    BuiltinOperator_ONE_HOT,
    BuiltinOperator_LOGICAL_AND,
    BuiltinOperator_LOGICAL_NOT,
    BuiltinOperator_UNPACK,
    BuiltinOperator_REDUCE_MIN,
    BuiltinOperator_FLOOR_DIV,
    BuiltinOperator_REDUCE_ANY,
    BuiltinOperator_SQUARE,
    BuiltinOperator_ZEROS_LIKE,
    BuiltinOperator_FILL,
    BuiltinOperator_FLOOR_MOD,
    BuiltinOperator_RANGE,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
    BuiltinOperator_LEAKY_RELU,
    BuiltinOperator_SQUARED_DIFFERENCE,
    BuiltinOperator_MIRROR_PAD,
    BuiltinOperator_ABS,
    BuiltinOperator_SPLIT_V
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOperator() {
  static const char * const names[104] = {
    "ADD",
    "AVERAGE_POOL_2D",
    "CONCATENATION",
    "CONV_2D",
    "DEPTHWISE_CONV_2D",
    "",
    "DEQUANTIZE",
    "EMBEDDING_LOOKUP",
    "FLOOR",
    "FULLY_CONNECTED",
    "HASHTABLE_LOOKUP",
    "L2_NORMALIZATION",
    "L2_POOL_2D",
    "LOCAL_RESPONSE_NORMALIZATION",
    "LOGISTIC",
    "LSH_PROJECTION",
    "LSTM",
    "MAX_POOL_2D",
    "MUL",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "RESHAPE",
    "RESIZE_BILINEAR",
    "RNN",
    "SOFTMAX",
    "SPACE_TO_DEPTH",
    "SVDF",
    "TANH",
    "CONCAT_EMBEDDINGS",
    "SKIP_GRAM",
    "CALL",
    "CUSTOM",
    "EMBEDDING_LOOKUP_SPARSE",
    "PAD",
    "UNIDIRECTIONAL_SEQUENCE_RNN",
    "GATHER",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "TRANSPOSE",
    "MEAN",
    "SUB",
    "DIV",
    "SQUEEZE",
    "UNIDIRECTIONAL_SEQUENCE_LSTM",
    "STRIDED_SLICE",
    "BIDIRECTIONAL_SEQUENCE_RNN",
    "EXP",
    "TOPK_V2",
    "SPLIT",
    "LOG_SOFTMAX",
    "DELEGATE",
    "BIDIRECTIONAL_SEQUENCE_LSTM",
    "CAST",
    "PRELU",
    "MAXIMUM",
    "ARG_MAX",
    "MINIMUM",
    "LESS",
    "NEG",
    "PADV2",
    "GREATER",
    "GREATER_EQUAL",
    "LESS_EQUAL",
    "SELECT",
    "SLICE",
    "SIN",
    "TRANSPOSE_CONV",
    "SPARSE_TO_DENSE",
    "TILE",
    "EXPAND_DIMS",
    "EQUAL",
    "NOT_EQUAL",
    "LOG",
    "SUM",
    "SQRT",
    "RSQRT",
    "SHAPE",
    "POW",
    "ARG_MIN",
    "FAKE_QUANT",
    "REDUCE_PROD",
    "REDUCE_MAX",
    "PACK",
    "LOGICAL_OR",
    "ONE_HOT",
    "LOGICAL_AND",
    "LOGICAL_NOT",
    "UNPACK",
    "REDUCE_MIN",
    "FLOOR_DIV",
    "REDUCE_ANY",
    "SQUARE",
    "ZEROS_LIKE",
    "FILL",
    "FLOOR_MOD",
    "RANGE",
    "RESIZE_NEAREST_NEIGHBOR",
    "LEAKY_RELU",
    "SQUARED_DIFFERENCE",
    "MIRROR_PAD",
    "ABS",
    "SPLIT_V",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
  if (flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_SPLIT_V)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_SplitVOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[80] {
  static const BuiltinOptions values[] = {
    BuiltinOptions_NONE,
    BuiltinOptions_Conv2DOptions,
    BuiltinOptions_DepthwiseConv2DOptions,
    BuiltinOptions_ConcatEmbeddingsOptions,
    BuiltinOptions_LSHProjectionOptions,
    BuiltinOptions_Pool2DOptions,
    BuiltinOptions_SVDFOptions,
    BuiltinOptions_RNNOptions,
    BuiltinOptions_FullyConnectedOptions,
    BuiltinOptions_SoftmaxOptions,
    BuiltinOptions_ConcatenationOptions,
    BuiltinOptions_AddOptions,
    BuiltinOptions_L2NormOptions,
    BuiltinOptions_LocalResponseNormalizationOptions,
    BuiltinOptions_LSTMOptions,
    BuiltinOptions_ResizeBilinearOptions,
    BuiltinOptions_CallOptions,
    BuiltinOptions_ReshapeOptions,
    BuiltinOptions_SkipGramOptions,
    BuiltinOptions_SpaceToDepthOptions,
    BuiltinOptions_EmbeddingLookupSparseOptions,
    BuiltinOptions_MulOptions,
    BuiltinOptions_PadOptions,
    BuiltinOptions_GatherOptions,
    BuiltinOptions_BatchToSpaceNDOptions,
    BuiltinOptions_SpaceToBatchNDOptions,
    BuiltinOptions_TransposeOptions,
    BuiltinOptions_ReducerOptions,
    BuiltinOptions_SubOptions,
    BuiltinOptions_DivOptions,
    BuiltinOptions_SqueezeOptions,
    BuiltinOptions_SequenceRNNOptions,
    BuiltinOptions_StridedSliceOptions,
    BuiltinOptions_ExpOptions,
    BuiltinOptions_TopKV2Options,
    BuiltinOptions_SplitOptions,
    BuiltinOptions_LogSoftmaxOptions,
    BuiltinOptions_CastOptions,
    BuiltinOptions_DequantizeOptions,
    BuiltinOptions_MaximumMinimumOptions,
    BuiltinOptions_ArgMaxOptions,
    BuiltinOptions_LessOptions,
    BuiltinOptions_NegOptions,
    BuiltinOptions_PadV2Options,
    BuiltinOptions_GreaterOptions,
    BuiltinOptions_GreaterEqualOptions,
    BuiltinOptions_LessEqualOptions,
    BuiltinOptions_SelectOptions,
    BuiltinOptions_SliceOptions,
    BuiltinOptions_TransposeConvOptions,
    BuiltinOptions_SparseToDenseOptions,
    BuiltinOptions_TileOptions,
    BuiltinOptions_ExpandDimsOptions,
    BuiltinOptions_EqualOptions,
    BuiltinOptions_NotEqualOptions,
    BuiltinOptions_ShapeOptions,
    BuiltinOptions_PowOptions,
    BuiltinOptions_ArgMinOptions,
    BuiltinOptions_FakeQuantOptions,
    BuiltinOptions_PackOptions,
    BuiltinOptions_LogicalOrOptions,
    BuiltinOptions_OneHotOptions,
    BuiltinOptions_LogicalAndOptions,
    BuiltinOptions_LogicalNotOptions,
    BuiltinOptions_UnpackOptions,
    BuiltinOptions_FloorDivOptions,
    BuiltinOptions_SquareOptions,
    BuiltinOptions_ZerosLikeOptions,
    BuiltinOptions_FillOptions,
    BuiltinOptions_BidirectionalSequenceLSTMOptions,
    BuiltinOptions_BidirectionalSequenceRNNOptions,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions,
    BuiltinOptions_FloorModOptions,
    BuiltinOptions_RangeOptions,
    BuiltinOptions_ResizeNearestNeighborOptions,
    BuiltinOptions_LeakyReluOptions,
    BuiltinOptions_SquaredDifferenceOptions,
    BuiltinOptions_MirrorPadOptions,
    BuiltinOptions_AbsOptions,
    BuiltinOptions_SplitVOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions() {
  static const char * const names[81] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
  if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_SplitVOptions)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template<typename T> struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsTraits<tflite::Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsTraits<tflite::L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsTraits<tflite::EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsTraits<tflite::OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

struct BuiltinOptionsUnion {
  BuiltinOptions type;
  void *value;

  BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
  BuiltinOptionsUnion(BuiltinOptionsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BuiltinOptions_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BuiltinOptionsUnion(const BuiltinOptionsUnion &);
  BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u)
    { BuiltinOptionsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BuiltinOptionsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = BuiltinOptionsTraits<typename RT::TableType>::enum_value;
    if (type != BuiltinOptions_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::Conv2DOptionsT *AsConv2DOptions() {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<tflite::Conv2DOptionsT *>(value) : nullptr;
  }
  const tflite::Conv2DOptionsT *AsConv2DOptions() const {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<const tflite::Conv2DOptionsT *>(value) : nullptr;
  }
  tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  const tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  const tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<tflite::LSHProjectionOptionsT *>(value) : nullptr;
  }
  const tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() const {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value) : nullptr;
  }
  tflite::Pool2DOptionsT *AsPool2DOptions() {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<tflite::Pool2DOptionsT *>(value) : nullptr;
  }
  const tflite::Pool2DOptionsT *AsPool2DOptions() const {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<const tflite::Pool2DOptionsT *>(value) : nullptr;
  }
  tflite::SVDFOptionsT *AsSVDFOptions() {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<tflite::SVDFOptionsT *>(value) : nullptr;
  }
  const tflite::SVDFOptionsT *AsSVDFOptions() const {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<const tflite::SVDFOptionsT *>(value) : nullptr;
  }
  tflite::RNNOptionsT *AsRNNOptions() {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<tflite::RNNOptionsT *>(value) : nullptr;
  }
  const tflite::RNNOptionsT *AsRNNOptions() const {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<const tflite::RNNOptionsT *>(value) : nullptr;
  }
  tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<tflite::FullyConnectedOptionsT *>(value) : nullptr;
  }
  const tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() const {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value) : nullptr;
  }
  tflite::SoftmaxOptionsT *AsSoftmaxOptions() {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<tflite::SoftmaxOptionsT *>(value) : nullptr;
  }
  const tflite::SoftmaxOptionsT *AsSoftmaxOptions() const {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<const tflite::SoftmaxOptionsT *>(value) : nullptr;
  }
  tflite::ConcatenationOptionsT *AsConcatenationOptions() {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<tflite::ConcatenationOptionsT *>(value) : nullptr;
  }
  const tflite::ConcatenationOptionsT *AsConcatenationOptions() const {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<const tflite::ConcatenationOptionsT *>(value) : nullptr;
  }
  tflite::AddOptionsT *AsAddOptions() {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<tflite::AddOptionsT *>(value) : nullptr;
  }
  const tflite::AddOptionsT *AsAddOptions() const {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<const tflite::AddOptionsT *>(value) : nullptr;
  }
  tflite::L2NormOptionsT *AsL2NormOptions() {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<tflite::L2NormOptionsT *>(value) : nullptr;
  }
  const tflite::L2NormOptionsT *AsL2NormOptions() const {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<const tflite::L2NormOptionsT *>(value) : nullptr;
  }
  tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  const tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  tflite::LSTMOptionsT *AsLSTMOptions() {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<tflite::LSTMOptionsT *>(value) : nullptr;
  }
  const tflite::LSTMOptionsT *AsLSTMOptions() const {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<const tflite::LSTMOptionsT *>(value) : nullptr;
  }
  tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value) : nullptr;
  }
  const tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() const {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value) : nullptr;
  }
  tflite::CallOptionsT *AsCallOptions() {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<tflite::CallOptionsT *>(value) : nullptr;
  }
  const tflite::CallOptionsT *AsCallOptions() const {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<const tflite::CallOptionsT *>(value) : nullptr;
  }
  tflite::ReshapeOptionsT *AsReshapeOptions() {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<tflite::ReshapeOptionsT *>(value) : nullptr;
  }
  const tflite::ReshapeOptionsT *AsReshapeOptions() const {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<const tflite::ReshapeOptionsT *>(value) : nullptr;
  }
  tflite::SkipGramOptionsT *AsSkipGramOptions() {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<tflite::SkipGramOptionsT *>(value) : nullptr;
  }
  const tflite::SkipGramOptionsT *AsSkipGramOptions() const {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<const tflite::SkipGramOptionsT *>(value) : nullptr;
  }
  tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value) : nullptr;
  }
  const tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() const {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value) : nullptr;
  }
  tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  tflite::MulOptionsT *AsMulOptions() {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<tflite::MulOptionsT *>(value) : nullptr;
  }
  const tflite::MulOptionsT *AsMulOptions() const {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<const tflite::MulOptionsT *>(value) : nullptr;
  }
  tflite::PadOptionsT *AsPadOptions() {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<tflite::PadOptionsT *>(value) : nullptr;
  }
  const tflite::PadOptionsT *AsPadOptions() const {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<const tflite::PadOptionsT *>(value) : nullptr;
  }
  tflite::GatherOptionsT *AsGatherOptions() {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<tflite::GatherOptionsT *>(value) : nullptr;
  }
  const tflite::GatherOptionsT *AsGatherOptions() const {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<const tflite::GatherOptionsT *>(value) : nullptr;
  }
  tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  const tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  const tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  tflite::TransposeOptionsT *AsTransposeOptions() {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<tflite::TransposeOptionsT *>(value) : nullptr;
  }
  const tflite::TransposeOptionsT *AsTransposeOptions() const {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<const tflite::TransposeOptionsT *>(value) : nullptr;
  }
  tflite::ReducerOptionsT *AsReducerOptions() {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<tflite::ReducerOptionsT *>(value) : nullptr;
  }
  const tflite::ReducerOptionsT *AsReducerOptions() const {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<const tflite::ReducerOptionsT *>(value) : nullptr;
  }
  tflite::SubOptionsT *AsSubOptions() {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<tflite::SubOptionsT *>(value) : nullptr;
  }
  const tflite::SubOptionsT *AsSubOptions() const {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<const tflite::SubOptionsT *>(value) : nullptr;
  }
  tflite::DivOptionsT *AsDivOptions() {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<tflite::DivOptionsT *>(value) : nullptr;
  }
  const tflite::DivOptionsT *AsDivOptions() const {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<const tflite::DivOptionsT *>(value) : nullptr;
  }
  tflite::SqueezeOptionsT *AsSqueezeOptions() {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<tflite::SqueezeOptionsT *>(value) : nullptr;
  }
  const tflite::SqueezeOptionsT *AsSqueezeOptions() const {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<const tflite::SqueezeOptionsT *>(value) : nullptr;
  }
  tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<tflite::SequenceRNNOptionsT *>(value) : nullptr;
  }
  const tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() const {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value) : nullptr;
  }
  tflite::StridedSliceOptionsT *AsStridedSliceOptions() {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<tflite::StridedSliceOptionsT *>(value) : nullptr;
  }
  const tflite::StridedSliceOptionsT *AsStridedSliceOptions() const {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<const tflite::StridedSliceOptionsT *>(value) : nullptr;
  }
  tflite::ExpOptionsT *AsExpOptions() {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<tflite::ExpOptionsT *>(value) : nullptr;
  }
  const tflite::ExpOptionsT *AsExpOptions() const {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<const tflite::ExpOptionsT *>(value) : nullptr;
  }
  tflite::TopKV2OptionsT *AsTopKV2Options() {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<tflite::TopKV2OptionsT *>(value) : nullptr;
  }
  const tflite::TopKV2OptionsT *AsTopKV2Options() const {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<const tflite::TopKV2OptionsT *>(value) : nullptr;
  }
  tflite::SplitOptionsT *AsSplitOptions() {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<tflite::SplitOptionsT *>(value) : nullptr;
  }
  const tflite::SplitOptionsT *AsSplitOptions() const {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<const tflite::SplitOptionsT *>(value) : nullptr;
  }
  tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value) : nullptr;
  }
  const tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() const {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value) : nullptr;
  }
  tflite::CastOptionsT *AsCastOptions() {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<tflite::CastOptionsT *>(value) : nullptr;
  }
  const tflite::CastOptionsT *AsCastOptions() const {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<const tflite::CastOptionsT *>(value) : nullptr;
  }
  tflite::DequantizeOptionsT *AsDequantizeOptions() {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<tflite::DequantizeOptionsT *>(value) : nullptr;
  }
  const tflite::DequantizeOptionsT *AsDequantizeOptions() const {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<const tflite::DequantizeOptionsT *>(value) : nullptr;
  }
  tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value) : nullptr;
  }
  const tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() const {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value) : nullptr;
  }
  tflite::ArgMaxOptionsT *AsArgMaxOptions() {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<tflite::ArgMaxOptionsT *>(value) : nullptr;
  }
  const tflite::ArgMaxOptionsT *AsArgMaxOptions() const {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<const tflite::ArgMaxOptionsT *>(value) : nullptr;
  }
  tflite::LessOptionsT *AsLessOptions() {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<tflite::LessOptionsT *>(value) : nullptr;
  }
  const tflite::LessOptionsT *AsLessOptions() const {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<const tflite::LessOptionsT *>(value) : nullptr;
  }
  tflite::NegOptionsT *AsNegOptions() {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<tflite::NegOptionsT *>(value) : nullptr;
  }
  const tflite::NegOptionsT *AsNegOptions() const {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<const tflite::NegOptionsT *>(value) : nullptr;
  }
  tflite::PadV2OptionsT *AsPadV2Options() {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<tflite::PadV2OptionsT *>(value) : nullptr;
  }
  const tflite::PadV2OptionsT *AsPadV2Options() const {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<const tflite::PadV2OptionsT *>(value) : nullptr;
  }
  tflite::GreaterOptionsT *AsGreaterOptions() {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<tflite::GreaterOptionsT *>(value) : nullptr;
  }
  const tflite::GreaterOptionsT *AsGreaterOptions() const {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<const tflite::GreaterOptionsT *>(value) : nullptr;
  }
  tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<tflite::GreaterEqualOptionsT *>(value) : nullptr;
  }
  const tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() const {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value) : nullptr;
  }
  tflite::LessEqualOptionsT *AsLessEqualOptions() {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<tflite::LessEqualOptionsT *>(value) : nullptr;
  }
  const tflite::LessEqualOptionsT *AsLessEqualOptions() const {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<const tflite::LessEqualOptionsT *>(value) : nullptr;
  }
  tflite::SelectOptionsT *AsSelectOptions() {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<tflite::SelectOptionsT *>(value) : nullptr;
  }
  const tflite::SelectOptionsT *AsSelectOptions() const {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<const tflite::SelectOptionsT *>(value) : nullptr;
  }
  tflite::SliceOptionsT *AsSliceOptions() {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<tflite::SliceOptionsT *>(value) : nullptr;
  }
  const tflite::SliceOptionsT *AsSliceOptions() const {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<const tflite::SliceOptionsT *>(value) : nullptr;
  }
  tflite::TransposeConvOptionsT *AsTransposeConvOptions() {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<tflite::TransposeConvOptionsT *>(value) : nullptr;
  }
  const tflite::TransposeConvOptionsT *AsTransposeConvOptions() const {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<const tflite::TransposeConvOptionsT *>(value) : nullptr;
  }
  tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<tflite::SparseToDenseOptionsT *>(value) : nullptr;
  }
  const tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() const {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value) : nullptr;
  }
  tflite::TileOptionsT *AsTileOptions() {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<tflite::TileOptionsT *>(value) : nullptr;
  }
  const tflite::TileOptionsT *AsTileOptions() const {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<const tflite::TileOptionsT *>(value) : nullptr;
  }
  tflite::ExpandDimsOptionsT *AsExpandDimsOptions() {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<tflite::ExpandDimsOptionsT *>(value) : nullptr;
  }
  const tflite::ExpandDimsOptionsT *AsExpandDimsOptions() const {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value) : nullptr;
  }
  tflite::EqualOptionsT *AsEqualOptions() {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<tflite::EqualOptionsT *>(value) : nullptr;
  }
  const tflite::EqualOptionsT *AsEqualOptions() const {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<const tflite::EqualOptionsT *>(value) : nullptr;
  }
  tflite::NotEqualOptionsT *AsNotEqualOptions() {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<tflite::NotEqualOptionsT *>(value) : nullptr;
  }
  const tflite::NotEqualOptionsT *AsNotEqualOptions() const {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<const tflite::NotEqualOptionsT *>(value) : nullptr;
  }
  tflite::ShapeOptionsT *AsShapeOptions() {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<tflite::ShapeOptionsT *>(value) : nullptr;
  }
  const tflite::ShapeOptionsT *AsShapeOptions() const {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<const tflite::ShapeOptionsT *>(value) : nullptr;
  }
  tflite::PowOptionsT *AsPowOptions() {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<tflite::PowOptionsT *>(value) : nullptr;
  }
  const tflite::PowOptionsT *AsPowOptions() const {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<const tflite::PowOptionsT *>(value) : nullptr;
  }
  tflite::ArgMinOptionsT *AsArgMinOptions() {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<tflite::ArgMinOptionsT *>(value) : nullptr;
  }
  const tflite::ArgMinOptionsT *AsArgMinOptions() const {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<const tflite::ArgMinOptionsT *>(value) : nullptr;
  }
  tflite::FakeQuantOptionsT *AsFakeQuantOptions() {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<tflite::FakeQuantOptionsT *>(value) : nullptr;
  }
  const tflite::FakeQuantOptionsT *AsFakeQuantOptions() const {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<const tflite::FakeQuantOptionsT *>(value) : nullptr;
  }
  tflite::PackOptionsT *AsPackOptions() {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<tflite::PackOptionsT *>(value) : nullptr;
  }
  const tflite::PackOptionsT *AsPackOptions() const {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<const tflite::PackOptionsT *>(value) : nullptr;
  }
  tflite::LogicalOrOptionsT *AsLogicalOrOptions() {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<tflite::LogicalOrOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalOrOptionsT *AsLogicalOrOptions() const {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<const tflite::LogicalOrOptionsT *>(value) : nullptr;
  }
  tflite::OneHotOptionsT *AsOneHotOptions() {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<tflite::OneHotOptionsT *>(value) : nullptr;
  }
  const tflite::OneHotOptionsT *AsOneHotOptions() const {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<const tflite::OneHotOptionsT *>(value) : nullptr;
  }
  tflite::LogicalAndOptionsT *AsLogicalAndOptions() {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<tflite::LogicalAndOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalAndOptionsT *AsLogicalAndOptions() const {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<const tflite::LogicalAndOptionsT *>(value) : nullptr;
  }
  tflite::LogicalNotOptionsT *AsLogicalNotOptions() {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<tflite::LogicalNotOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalNotOptionsT *AsLogicalNotOptions() const {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<const tflite::LogicalNotOptionsT *>(value) : nullptr;
  }
  tflite::UnpackOptionsT *AsUnpackOptions() {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<tflite::UnpackOptionsT *>(value) : nullptr;
  }
  const tflite::UnpackOptionsT *AsUnpackOptions() const {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<const tflite::UnpackOptionsT *>(value) : nullptr;
  }
  tflite::FloorDivOptionsT *AsFloorDivOptions() {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<tflite::FloorDivOptionsT *>(value) : nullptr;
  }
  const tflite::FloorDivOptionsT *AsFloorDivOptions() const {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<const tflite::FloorDivOptionsT *>(value) : nullptr;
  }
  tflite::SquareOptionsT *AsSquareOptions() {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<tflite::SquareOptionsT *>(value) : nullptr;
  }
  const tflite::SquareOptionsT *AsSquareOptions() const {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<const tflite::SquareOptionsT *>(value) : nullptr;
  }
  tflite::ZerosLikeOptionsT *AsZerosLikeOptions() {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<tflite::ZerosLikeOptionsT *>(value) : nullptr;
  }
  const tflite::ZerosLikeOptionsT *AsZerosLikeOptions() const {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value) : nullptr;
  }
  tflite::FillOptionsT *AsFillOptions() {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<tflite::FillOptionsT *>(value) : nullptr;
  }
  const tflite::FillOptionsT *AsFillOptions() const {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<const tflite::FillOptionsT *>(value) : nullptr;
  }
  tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  tflite::FloorModOptionsT *AsFloorModOptions() {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<tflite::FloorModOptionsT *>(value) : nullptr;
  }
  const tflite::FloorModOptionsT *AsFloorModOptions() const {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<const tflite::FloorModOptionsT *>(value) : nullptr;
  }
  tflite::RangeOptionsT *AsRangeOptions() {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<tflite::RangeOptionsT *>(value) : nullptr;
  }
  const tflite::RangeOptionsT *AsRangeOptions() const {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<const tflite::RangeOptionsT *>(value) : nullptr;
  }
  tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  const tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() const {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  tflite::LeakyReluOptionsT *AsLeakyReluOptions() {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<tflite::LeakyReluOptionsT *>(value) : nullptr;
  }
  const tflite::LeakyReluOptionsT *AsLeakyReluOptions() const {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<const tflite::LeakyReluOptionsT *>(value) : nullptr;
  }
  tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  const tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() const {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  tflite::MirrorPadOptionsT *AsMirrorPadOptions() {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<tflite::MirrorPadOptionsT *>(value) : nullptr;
  }
  const tflite::MirrorPadOptionsT *AsMirrorPadOptions() const {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<const tflite::MirrorPadOptionsT *>(value) : nullptr;
  }
  tflite::AbsOptionsT *AsAbsOptions() {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<tflite::AbsOptionsT *>(value) : nullptr;
  }
  const tflite::AbsOptionsT *AsAbsOptions() const {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<const tflite::AbsOptionsT *>(value) : nullptr;
  }
  tflite::SplitVOptionsT *AsSplitVOptions() {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<tflite::SplitVOptionsT *>(value) : nullptr;
  }
  const tflite::SplitVOptionsT *AsSplitVOptions() const {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<const tflite::SplitVOptionsT *>(value) : nullptr;
  }
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Padding {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {
    Padding_SAME,
    Padding_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadding() {
  static const char * const names[3] = {
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadding(Padding e) {
  if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,
    ActivationFunctionType_RELU,
    ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6,
    ActivationFunctionType_TANH,
    ActivationFunctionType_SIGN_BIT
  };
  return values;
}

inline const char * const *EnumNamesActivationFunctionType() {
  static const char * const names[7] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
  if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {
    LSHProjectionType_UNKNOWN,
    LSHProjectionType_SPARSE,
    LSHProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLSHProjectionType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
  if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
  };
  return values;
}

inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char * const names[3] = {
    "DEFAULT",
    "SHUFFLED4x16INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
  if (flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {
    LSTMKernelType_FULL,
    LSTMKernelType_BASIC
  };
  return values;
}

inline const char * const *EnumNamesLSTMKernelType() {
  static const char * const names[3] = {
    "FULL",
    "BASIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
  if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {
    CombinerType_SUM,
    CombinerType_MEAN,
    CombinerType_SQRTN
  };
  return values;
}

inline const char * const *EnumNamesCombinerType() {
  static const char * const names[4] = {
    "SUM",
    "MEAN",
    "SQRTN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
  if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {
    MirrorPadMode_REFLECT,
    MirrorPadMode_SYMMETRIC
  };
  return values;
}

inline const char * const *EnumNamesMirrorPadMode() {
  static const char * const names[3] = {
    "REFLECT",
    "SYMMETRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
  if (flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum CustomOptionsFormat {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {
    CustomOptionsFormat_FLEXBUFFERS
  };
  return values;
}

inline const char * const *EnumNamesCustomOptionsFormat() {
  static const char * const names[2] = {
    "FLEXBUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantizationT : public flatbuffers::NativeTable {
  typedef CustomQuantization TableType;
  std::vector<uint8_t> custom;
  CustomQuantizationT() {
  }
};

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomQuantizationT NativeTableType;
  typedef CustomQuantizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  flatbuffers::Vector<uint8_t> *mutable_custom() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
  CustomQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomQuantization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomQuantizationBuilder {
  typedef CustomQuantization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomQuantizationBuilder &operator=(const CustomQuantizationBuilder &);
  flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  if (custom) { _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16); }
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      custom__);
}

flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizationParametersT : public flatbuffers::NativeTable {
  typedef QuantizationParameters TableType;
  std::vector<float> min;
  std::vector<float> max;
  std::vector<float> scale;
  std::vector<int64_t> zero_point;
  tflite::QuantizationDetailsUnion details;
  QuantizationParametersT() {
  }
};

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizationParametersT NativeTableType;
  typedef QuantizationParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14
  };
  const flatbuffers::Vector<float> *min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
  }
  flatbuffers::Vector<float> *mutable_min() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_MIN);
  }
  const flatbuffers::Vector<float> *max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
  }
  flatbuffers::Vector<float> *mutable_max() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_MAX);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  flatbuffers::Vector<float> *mutable_scale() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<int64_t> *zero_point() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  flatbuffers::Vector<int64_t> *mutable_zero_point() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  tflite::QuantizationDetails details_type() const {
    return static_cast<tflite::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const {
    return GetPointer<const void *>(VT_DETAILS);
  }
  template<typename T> const T *details_as() const;
  const tflite::CustomQuantization *details_as_CustomQuantization() const {
    return details_type() == tflite::QuantizationDetails_CustomQuantization ? static_cast<const tflite::CustomQuantization *>(details()) : nullptr;
  }
  void *mutable_details() {
    return GetPointer<void *>(VT_DETAILS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           verifier.EndTable();
  }
  QuantizationParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizationParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::CustomQuantization *QuantizationParameters::details_as<tflite::CustomQuantization>() const {
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
  typedef QuantizationParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(tflite::QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
  flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zero_point = nullptr,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0) {
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return tflite::CreateQuantizationParameters(
      _fbb,
      min__,
      max__,
      scale__,
      zero_point__,
      details_type,
      details);
}

flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
  typedef Tensor TableType;
  std::vector<int32_t> shape;
  tflite::TensorType type;
  uint32_t buffer;
  std::string name;
  std::unique_ptr<tflite::QuantizationParametersT> quantization;
  bool is_variable;
  TensorT()
      : type(tflite::TensorType_FLOAT32),
        buffer(0),
        is_variable(false) {
  }
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorT NativeTableType;
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14
  };
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  tflite::TensorType type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(tflite::TensorType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  bool mutate_buffer(uint32_t _buffer) {
    return SetField<uint32_t>(VT_BUFFER, _buffer, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const tflite::QuantizationParameters *quantization() const {
    return GetPointer<const tflite::QuantizationParameters *>(VT_QUANTIZATION);
  }
  tflite::QuantizationParameters *mutable_quantization() {
    return GetPointer<tflite::QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const {
    return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
  }
  bool mutate_is_variable(bool _is_variable) {
    return SetField<uint8_t>(VT_IS_VARIABLE, static_cast<uint8_t>(_is_variable), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(tflite::TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(flatbuffers::Offset<tflite::QuantizationParameters> quantization) {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    uint32_t buffer = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false) {
  TensorBuilder builder_(_fbb);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    uint32_t buffer = 0,
    const char *name = nullptr,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateTensor(
      _fbb,
      shape__,
      type,
      buffer,
      name__,
      quantization,
      is_variable);
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public flatbuffers::NativeTable {
  typedef Conv2DOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  tflite::ActivationFunctionType fused_activation_function;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  Conv2DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DOptionsT NativeTableType;
  typedef Conv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  bool mutate_padding(tflite::Padding _padding) {
    return SetField<int8_t>(VT_PADDING, static_cast<int8_t>(_padding), 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  bool mutate_stride_w(int32_t _stride_w) {
    return SetField<int32_t>(VT_STRIDE_W, _stride_w, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  bool mutate_stride_h(int32_t _stride_h) {
    return SetField<int32_t>(VT_STRIDE_H, _stride_h, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  bool mutate_dilation_w_factor(int32_t _dilation_w_factor) {
    return SetField<int32_t>(VT_DILATION_W_FACTOR, _dilation_w_factor, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool mutate_dilation_h_factor(int32_t _dilation_h_factor) {
    return SetField<int32_t>(VT_DILATION_H_FACTOR, _dilation_h_factor, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
  Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder {
  typedef Conv2DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
  flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public flatbuffers::NativeTable {
  typedef Pool2DOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  int32_t filter_width;
  int32_t filter_height;
  tflite::ActivationFunctionType fused_activation_function;
  Pool2DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0),
        filter_width(0),
        filter_height(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool2DOptionsT NativeTableType;
  typedef Pool2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  bool mutate_padding(tflite::Padding _padding) {
    return SetField<int8_t>(VT_PADDING, static_cast<int8_t>(_padding), 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  bool mutate_stride_w(int32_t _stride_w) {
    return SetField<int32_t>(VT_STRIDE_W, _stride_w, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  bool mutate_stride_h(int32_t _stride_h) {
    return SetField<int32_t>(VT_STRIDE_H, _stride_h, 0);
  }
  int32_t filter_width() const {
    return GetField<int32_t>(VT_FILTER_WIDTH, 0);
  }
  bool mutate_filter_width(int32_t _filter_width) {
    return SetField<int32_t>(VT_FILTER_WIDTH, _filter_width, 0);
  }
  int32_t filter_height() const {
    return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
  }
  bool mutate_filter_height(int32_t _filter_height) {
    return SetField<int32_t>(VT_FILTER_HEIGHT, _filter_height, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder {
  typedef Pool2DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
  flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {
  typedef DepthwiseConv2DOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  int32_t depth_multiplier;
  tflite::ActivationFunctionType fused_activation_function;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  DepthwiseConv2DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0),
        depth_multiplier(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthwiseConv2DOptionsT NativeTableType;
  typedef DepthwiseConv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  bool mutate_padding(tflite::Padding _padding) {
    return SetField<int8_t>(VT_PADDING, static_cast<int8_t>(_padding), 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  bool mutate_stride_w(int32_t _stride_w) {
    return SetField<int32_t>(VT_STRIDE_W, _stride_w, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  bool mutate_stride_h(int32_t _stride_h) {
    return SetField<int32_t>(VT_STRIDE_H, _stride_h, 0);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  bool mutate_depth_multiplier(int32_t _depth_multiplier) {
    return SetField<int32_t>(VT_DEPTH_MULTIPLIER, _depth_multiplier, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  bool mutate_dilation_w_factor(int32_t _dilation_w_factor) {
    return SetField<int32_t>(VT_DILATION_W_FACTOR, _dilation_w_factor, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool mutate_dilation_h_factor(int32_t _dilation_h_factor) {
    return SetField<int32_t>(VT_DILATION_H_FACTOR, _dilation_h_factor, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
  DepthwiseConv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthwiseConv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder {
  typedef DepthwiseConv2DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable {
  typedef ConcatEmbeddingsOptions TableType;
  int32_t num_channels;
  std::vector<int32_t> num_columns_per_channel;
  std::vector<int32_t> embedding_dim_per_channel;
  ConcatEmbeddingsOptionsT()
      : num_channels(0) {
  }
};

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatEmbeddingsOptionsT NativeTableType;
  typedef ConcatEmbeddingsOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const {
    return GetField<int32_t>(VT_NUM_CHANNELS, 0);
  }
  bool mutate_num_channels(int32_t _num_channels) {
    return SetField<int32_t>(VT_NUM_CHANNELS, _num_channels, 0);
  }
  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  flatbuffers::Vector<int32_t> *mutable_num_columns_per_channel() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  flatbuffers::Vector<int32_t> *mutable_embedding_dim_per_channel() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
  ConcatEmbeddingsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder {
  typedef ConcatEmbeddingsOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
  auto num_columns_per_channel__ = num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
  auto embedding_dim_per_channel__ = embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      num_channels,
      num_columns_per_channel__,
      embedding_dim_per_channel__);
}

flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public flatbuffers::NativeTable {
  typedef LSHProjectionOptions TableType;
  tflite::LSHProjectionType type;
  LSHProjectionOptionsT()
      : type(tflite::LSHProjectionType_UNKNOWN) {
  }
};

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSHProjectionOptionsT NativeTableType;
  typedef LSHProjectionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  tflite::LSHProjectionType type() const {
    return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(tflite::LSHProjectionType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSHProjectionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder {
  typedef LSHProjectionOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(tflite::LSHProjectionType type) {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
  flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public flatbuffers::NativeTable {
  typedef SVDFOptions TableType;
  int32_t rank;
  tflite::ActivationFunctionType fused_activation_function;
  SVDFOptionsT()
      : rank(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SVDFOptionsT NativeTableType;
  typedef SVDFOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  bool mutate_rank(int32_t _rank) {
    return SetField<int32_t>(VT_RANK, _rank, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SVDFOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder {
  typedef SVDFOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
  flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public flatbuffers::NativeTable {
  typedef RNNOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  RNNOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RNNOptionsT NativeTableType;
  typedef RNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder {
  typedef RNNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
  flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public flatbuffers::NativeTable {
  typedef SequenceRNNOptions TableType;
  bool time_major;
  tflite::ActivationFunctionType fused_activation_function;
  SequenceRNNOptionsT()
      : time_major(false),
        fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceRNNOptionsT NativeTableType;
  typedef SequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool mutate_time_major(bool _time_major) {
    return SetField<uint8_t>(VT_TIME_MAJOR, static_cast<uint8_t>(_time_major), 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder {
  typedef SequenceRNNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
  flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {
  typedef BidirectionalSequenceRNNOptions TableType;
  bool time_major;
  tflite::ActivationFunctionType fused_activation_function;
  bool merge_outputs;
  BidirectionalSequenceRNNOptionsT()
      : time_major(false),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        merge_outputs(false) {
  }
};

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BidirectionalSequenceRNNOptionsT NativeTableType;
  typedef BidirectionalSequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool mutate_time_major(bool _time_major) {
    return SetField<uint8_t>(VT_TIME_MAJOR, static_cast<uint8_t>(_time_major), 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool mutate_merge_outputs(bool _merge_outputs) {
    return SetField<uint8_t>(VT_MERGE_OUTPUTS, static_cast<uint8_t>(_merge_outputs), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           verifier.EndTable();
  }
  BidirectionalSequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder {
  typedef BidirectionalSequenceRNNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool merge_outputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public flatbuffers::NativeTable {
  typedef FullyConnectedOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  tflite::FullyConnectedOptionsWeightsFormat weights_format;
  FullyConnectedOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        weights_format(tflite::FullyConnectedOptionsWeightsFormat_DEFAULT) {
  }
};

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullyConnectedOptionsT NativeTableType;
  typedef FullyConnectedOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  tflite::FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<tflite::FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool mutate_weights_format(tflite::FullyConnectedOptionsWeightsFormat _weights_format) {
    return SetField<int8_t>(VT_WEIGHTS_FORMAT, static_cast<int8_t>(_weights_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) &&
           verifier.EndTable();
  }
  FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FullyConnectedOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder {
  typedef FullyConnectedOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(tflite::FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
  flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public flatbuffers::NativeTable {
  typedef SoftmaxOptions TableType;
  float beta;
  SoftmaxOptionsT()
      : beta(0.0f) {
  }
};

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxOptionsT NativeTableType;
  typedef SoftmaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder {
  typedef SoftmaxOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
  }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
  flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public flatbuffers::NativeTable {
  typedef ConcatenationOptions TableType;
  int32_t axis;
  tflite::ActivationFunctionType fused_activation_function;
  ConcatenationOptionsT()
      : axis(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatenationOptionsT NativeTableType;
  typedef ConcatenationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatenationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder {
  typedef ConcatenationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
  flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public flatbuffers::NativeTable {
  typedef AddOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  AddOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddOptionsT NativeTableType;
  typedef AddOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder {
  typedef AddOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionsBuilder &operator=(const AddOptionsBuilder &);
  flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public flatbuffers::NativeTable {
  typedef MulOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  MulOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulOptionsT NativeTableType;
  typedef MulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder {
  typedef MulOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionsBuilder &operator=(const MulOptionsBuilder &);
  flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public flatbuffers::NativeTable {
  typedef L2NormOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  L2NormOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef L2NormOptionsT NativeTableType;
  typedef L2NormOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<L2NormOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder {
  typedef L2NormOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
  flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {
  typedef LocalResponseNormalizationOptions TableType;
  int32_t radius;
  float bias;
  float alpha;
  float beta;
  LocalResponseNormalizationOptionsT()
      : radius(0),
        bias(0.0f),
        alpha(0.0f),
        beta(0.0f) {
  }
};

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocalResponseNormalizationOptionsT NativeTableType;
  typedef LocalResponseNormalizationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  bool mutate_radius(int32_t _radius) {
    return SetField<int32_t>(VT_RADIUS, _radius, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  bool mutate_bias(float _bias) {
    return SetField<float>(VT_BIAS, _bias, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  LocalResponseNormalizationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder {
  typedef LocalResponseNormalizationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public flatbuffers::NativeTable {
  typedef LSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  tflite::LSTMKernelType kernel_type;
  LSTMOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        kernel_type(tflite::LSTMKernelType_FULL) {
  }
};

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMOptionsT NativeTableType;
  typedef LSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  bool mutate_cell_clip(float _cell_clip) {
    return SetField<float>(VT_CELL_CLIP, _cell_clip, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool mutate_proj_clip(float _proj_clip) {
    return SetField<float>(VT_PROJ_CLIP, _proj_clip, 0.0f);
  }
  tflite::LSTMKernelType kernel_type() const {
    return static_cast<tflite::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool mutate_kernel_type(tflite::LSTMKernelType _kernel_type) {
    return SetField<int8_t>(VT_KERNEL_TYPE, static_cast<int8_t>(_kernel_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
           verifier.EndTable();
  }
  LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder {
  typedef LSTMOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(tflite::LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
  flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
  typedef UnidirectionalSequenceLSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  bool time_major;
  UnidirectionalSequenceLSTMOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        time_major(false) {
  }
};

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;
  typedef UnidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  bool mutate_cell_clip(float _cell_clip) {
    return SetField<float>(VT_CELL_CLIP, _cell_clip, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool mutate_proj_clip(float _proj_clip) {
    return SetField<float>(VT_PROJ_CLIP, _proj_clip, 0.0f);
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool mutate_time_major(bool _time_major) {
    return SetField<uint8_t>(VT_TIME_MAJOR, static_cast<uint8_t>(_time_major), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           verifier.EndTable();
  }
  UnidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  typedef UnidirectionalSequenceLSTMOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnidirectionalSequenceLSTMOptionsBuilder &operator=(const UnidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool time_major = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
  typedef BidirectionalSequenceLSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  bool merge_outputs;
  BidirectionalSequenceLSTMOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        merge_outputs(false) {
  }
};

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BidirectionalSequenceLSTMOptionsT NativeTableType;
  typedef BidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  bool mutate_cell_clip(float _cell_clip) {
    return SetField<float>(VT_CELL_CLIP, _cell_clip, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool mutate_proj_clip(float _proj_clip) {
    return SetField<float>(VT_PROJ_CLIP, _proj_clip, 0.0f);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool mutate_merge_outputs(bool _merge_outputs) {
    return SetField<uint8_t>(VT_MERGE_OUTPUTS, static_cast<uint8_t>(_merge_outputs), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           verifier.EndTable();
  }
  BidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  typedef BidirectionalSequenceLSTMOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceLSTMOptionsBuilder &operator=(const BidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool merge_outputs = false) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public flatbuffers::NativeTable {
  typedef ResizeBilinearOptions TableType;
  bool align_corners;
  ResizeBilinearOptionsT()
      : align_corners(false) {
  }
};

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeBilinearOptionsT NativeTableType;
  typedef ResizeBilinearOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 8
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool mutate_align_corners(bool _align_corners) {
    return SetField<uint8_t>(VT_ALIGN_CORNERS, static_cast<uint8_t>(_align_corners), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
  ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeBilinearOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder {
  typedef ResizeBilinearOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
  flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeNearestNeighborOptionsT : public flatbuffers::NativeTable {
  typedef ResizeNearestNeighborOptions TableType;
  bool align_corners;
  ResizeNearestNeighborOptionsT()
      : align_corners(false) {
  }
};

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeNearestNeighborOptionsT NativeTableType;
  typedef ResizeNearestNeighborOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 4
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool mutate_align_corners(bool _align_corners) {
    return SetField<uint8_t>(VT_ALIGN_CORNERS, static_cast<uint8_t>(_align_corners), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
  ResizeNearestNeighborOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeNearestNeighborOptionsBuilder {
  typedef ResizeNearestNeighborOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeNearestNeighborOptionsBuilder &operator=(const ResizeNearestNeighborOptionsBuilder &);
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public flatbuffers::NativeTable {
  typedef CallOptions TableType;
  uint32_t subgraph;
  CallOptionsT()
      : subgraph(0) {
  }
};

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallOptionsT NativeTableType;
  typedef CallOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const {
    return GetField<uint32_t>(VT_SUBGRAPH, 0);
  }
  bool mutate_subgraph(uint32_t _subgraph) {
    return SetField<uint32_t>(VT_SUBGRAPH, _subgraph, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH) &&
           verifier.EndTable();
  }
  CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder {
  typedef CallOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOptionsBuilder &operator=(const CallOptionsBuilder &);
  flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public flatbuffers::NativeTable {
  typedef PadOptions TableType;
  PadOptionsT() {
  }
};

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadOptionsT NativeTableType;
  typedef PadOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder {
  typedef PadOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadOptionsBuilder &operator=(const PadOptionsBuilder &);
  flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public flatbuffers::NativeTable {
  typedef PadV2Options TableType;
  PadV2OptionsT() {
  }
};

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadV2OptionsT NativeTableType;
  typedef PadV2OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder {
  typedef PadV2Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
  flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public flatbuffers::NativeTable {
  typedef ReshapeOptions TableType;
  std::vector<int32_t> new_shape;
  ReshapeOptionsT() {
  }
};

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeOptionsT NativeTableType;
  typedef ReshapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_new_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
  ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder {
  typedef ReshapeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
  flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *new_shape = nullptr) {
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      new_shape__);
}

flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable {
  typedef SpaceToBatchNDOptions TableType;
  SpaceToBatchNDOptionsT() {
  }
};

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchNDOptionsT NativeTableType;
  typedef SpaceToBatchNDOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatchNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder {
  typedef SpaceToBatchNDOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable {
  typedef BatchToSpaceNDOptions TableType;
  BatchToSpaceNDOptionsT() {
  }
};

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceNDOptionsT NativeTableType;
  typedef BatchToSpaceNDOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpaceNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder {
  typedef BatchToSpaceNDOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public flatbuffers::NativeTable {
  typedef SkipGramOptions TableType;
  int32_t ngram_size;
  int32_t max_skip_size;
  bool include_all_ngrams;
  SkipGramOptionsT()
      : ngram_size(0),
        max_skip_size(0),
        include_all_ngrams(false) {
  }
};

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkipGramOptionsT NativeTableType;
  typedef SkipGramOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const {
    return GetField<int32_t>(VT_NGRAM_SIZE, 0);
  }
  bool mutate_ngram_size(int32_t _ngram_size) {
    return SetField<int32_t>(VT_NGRAM_SIZE, _ngram_size, 0);
  }
  int32_t max_skip_size() const {
    return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool mutate_max_skip_size(int32_t _max_skip_size) {
    return SetField<int32_t>(VT_MAX_SKIP_SIZE, _max_skip_size, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
  }
  bool mutate_include_all_ngrams(bool _include_all_ngrams) {
    return SetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(_include_all_ngrams), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) &&
           verifier.EndTable();
  }
  SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkipGramOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder {
  typedef SkipGramOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
  flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ngram_size = 0,
    int32_t max_skip_size = 0,
    bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public flatbuffers::NativeTable {
  typedef SpaceToDepthOptions TableType;
  int32_t block_size;
  SpaceToDepthOptionsT()
      : block_size(0) {
  }
};

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToDepthOptionsT NativeTableType;
  typedef SpaceToDepthOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool mutate_block_size(int32_t _block_size) {
    return SetField<int32_t>(VT_BLOCK_SIZE, _block_size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
  SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToDepthOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder {
  typedef SpaceToDepthOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
  flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public flatbuffers::NativeTable {
  typedef SubOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  SubOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubOptionsT NativeTableType;
  typedef SubOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder {
  typedef SubOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubOptionsBuilder &operator=(const SubOptionsBuilder &);
  flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public flatbuffers::NativeTable {
  typedef DivOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  DivOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivOptionsT NativeTableType;
  typedef DivOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool mutate_fused_activation_function(tflite::ActivationFunctionType _fused_activation_function) {
    return SetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(_fused_activation_function), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder {
  typedef DivOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionsBuilder &operator=(const DivOptionsBuilder &);
  flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public flatbuffers::NativeTable {
  typedef TopKV2Options TableType;
  TopKV2OptionsT() {
  }
};

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKV2OptionsT NativeTableType;
  typedef TopKV2OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder {
  typedef TopKV2Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
  flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable {
  typedef EmbeddingLookupSparseOptions TableType;
  tflite::CombinerType combiner;
  EmbeddingLookupSparseOptionsT()
      : combiner(tflite::CombinerType_SUM) {
  }
};

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingLookupSparseOptionsT NativeTableType;
  typedef EmbeddingLookupSparseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMBINER = 4
  };
  tflite::CombinerType combiner() const {
    return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool mutate_combiner(tflite::CombinerType _combiner) {
    return SetField<int8_t>(VT_COMBINER, static_cast<int8_t>(_combiner), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMBINER) &&
           verifier.EndTable();
  }
  EmbeddingLookupSparseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder {
  typedef EmbeddingLookupSparseOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(tflite::CombinerType combiner) {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::CombinerType combiner = tflite::CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public flatbuffers::NativeTable {
  typedef GatherOptions TableType;
  int32_t axis;
  GatherOptionsT()
      : axis(0) {
  }
};

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherOptionsT NativeTableType;
  typedef GatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder {
  typedef GatherOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
  flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public flatbuffers::NativeTable {
  typedef TransposeOptions TableType;
  TransposeOptionsT() {
  }
};

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeOptionsT NativeTableType;
  typedef TransposeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder {
  typedef TransposeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
  flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public flatbuffers::NativeTable {
  typedef ExpOptions TableType;
  ExpOptionsT() {
  }
};

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpOptionsT NativeTableType;
  typedef ExpOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder {
  typedef ExpOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
  flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public flatbuffers::NativeTable {
  typedef ReducerOptions TableType;
  bool keep_dims;
  ReducerOptionsT()
      : keep_dims(false) {
  }
};

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReducerOptionsT NativeTableType;
  typedef ReducerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool mutate_keep_dims(bool _keep_dims) {
    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
  ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReducerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder {
  typedef ReducerOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
  flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public flatbuffers::NativeTable {
  typedef SqueezeOptions TableType;
  std::vector<int32_t> squeeze_dims;
  SqueezeOptionsT() {
  }
};

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeOptionsT NativeTableType;
  typedef SqueezeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  flatbuffers::Vector<int32_t> *mutable_squeeze_dims() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
  SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqueezeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder {
  typedef SqueezeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
  flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeeze_dims = nullptr) {
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      squeeze_dims__);
}

flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public flatbuffers::NativeTable {
  typedef SplitOptions TableType;
  int32_t num_splits;
  SplitOptionsT()
      : num_splits(0) {
  }
};

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitOptionsT NativeTableType;
  typedef SplitOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool mutate_num_splits(int32_t _num_splits) {
    return SetField<int32_t>(VT_NUM_SPLITS, _num_splits, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
  SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder {
  typedef SplitOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
  flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitVOptionsT : public flatbuffers::NativeTable {
  typedef SplitVOptions TableType;
  int32_t num_splits;
  SplitVOptionsT()
      : num_splits(0) {
  }
};

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitVOptionsT NativeTableType;
  typedef SplitVOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool mutate_num_splits(int32_t _num_splits) {
    return SetField<int32_t>(VT_NUM_SPLITS, _num_splits, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
  SplitVOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitVOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitVOptionsBuilder {
  typedef SplitVOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitVOptionsBuilder &operator=(const SplitVOptionsBuilder &);
  flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public flatbuffers::NativeTable {
  typedef StridedSliceOptions TableType;
  int32_t begin_mask;
  int32_t end_mask;
  int32_t ellipsis_mask;
  int32_t new_axis_mask;
  int32_t shrink_axis_mask;
  StridedSliceOptionsT()
      : begin_mask(0),
        end_mask(0),
        ellipsis_mask(0),
        new_axis_mask(0),
        shrink_axis_mask(0) {
  }
};

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceOptionsT NativeTableType;
  typedef StridedSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  bool mutate_begin_mask(int32_t _begin_mask) {
    return SetField<int32_t>(VT_BEGIN_MASK, _begin_mask, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  bool mutate_end_mask(int32_t _end_mask) {
    return SetField<int32_t>(VT_END_MASK, _end_mask, 0);
  }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
  }
  bool mutate_ellipsis_mask(int32_t _ellipsis_mask) {
    return SetField<int32_t>(VT_ELLIPSIS_MASK, _ellipsis_mask, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
  }
  bool mutate_new_axis_mask(int32_t _new_axis_mask) {
    return SetField<int32_t>(VT_NEW_AXIS_MASK, _new_axis_mask, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool mutate_shrink_axis_mask(int32_t _shrink_axis_mask) {
    return SetField<int32_t>(VT_SHRINK_AXIS_MASK, _shrink_axis_mask, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
  StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder {
  typedef StridedSliceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
  flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t ellipsis_mask = 0,
    int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public flatbuffers::NativeTable {
  typedef LogSoftmaxOptions TableType;
  LogSoftmaxOptionsT() {
  }
};

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogSoftmaxOptionsT NativeTableType;
  typedef LogSoftmaxOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder {
  typedef LogSoftmaxOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
  flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public flatbuffers::NativeTable {
  typedef CastOptions TableType;
  tflite::TensorType in_data_type;
  tflite::TensorType out_data_type;
  CastOptionsT()
      : in_data_type(tflite::TensorType_FLOAT32),
        out_data_type(tflite::TensorType_FLOAT32) {
  }
};

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastOptionsT NativeTableType;
  typedef CastOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  tflite::TensorType in_data_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  bool mutate_in_data_type(tflite::TensorType _in_data_type) {
    return SetField<int8_t>(VT_IN_DATA_TYPE, static_cast<int8_t>(_in_data_type), 0);
  }
  tflite::TensorType out_data_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool mutate_out_data_type(tflite::TensorType _out_data_type) {
    return SetField<int8_t>(VT_OUT_DATA_TYPE, static_cast<int8_t>(_out_data_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) &&
           verifier.EndTable();
  }
  CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder {
  typedef CastOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(tflite::TensorType in_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(tflite::TensorType out_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastOptionsBuilder &operator=(const CastOptionsBuilder &);
  flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,
    tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public flatbuffers::NativeTable {
  typedef DequantizeOptions TableType;
  DequantizeOptionsT() {
  }
};

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DequantizeOptionsT NativeTableType;
  typedef DequantizeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DequantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder {
  typedef DequantizeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
  flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public flatbuffers::NativeTable {
  typedef MaximumMinimumOptions TableType;
  MaximumMinimumOptionsT() {
  }
};

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumMinimumOptionsT NativeTableType;
  typedef MaximumMinimumOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaximumMinimumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder {
  typedef MaximumMinimumOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
  flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public flatbuffers::NativeTable {
  typedef TileOptions TableType;
  TileOptionsT() {
  }
};

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileOptionsT NativeTableType;
  typedef TileOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder {
  typedef TileOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileOptionsBuilder &operator=(const TileOptionsBuilder &);
  flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public flatbuffers::NativeTable {
  typedef ArgMaxOptions TableType;
  tflite::TensorType output_type;
  ArgMaxOptionsT()
      : output_type(tflite::TensorType_FLOAT32) {
  }
};

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxOptionsT NativeTableType;
  typedef ArgMaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool mutate_output_type(tflite::TensorType _output_type) {
    return SetField<int8_t>(VT_OUTPUT_TYPE, static_cast<int8_t>(_output_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
  ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder {
  typedef ArgMaxOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
  flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public flatbuffers::NativeTable {
  typedef ArgMinOptions TableType;
  tflite::TensorType output_type;
  ArgMinOptionsT()
      : output_type(tflite::TensorType_FLOAT32) {
  }
};

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMinOptionsT NativeTableType;
  typedef ArgMinOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool mutate_output_type(tflite::TensorType _output_type) {
    return SetField<int8_t>(VT_OUTPUT_TYPE, static_cast<int8_t>(_output_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
  ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder {
  typedef ArgMinOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
  flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public flatbuffers::NativeTable {
  typedef GreaterOptions TableType;
  GreaterOptionsT() {
  }
};

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterOptionsT NativeTableType;
  typedef GreaterOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder {
  typedef GreaterOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
  flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public flatbuffers::NativeTable {
  typedef GreaterEqualOptions TableType;
  GreaterEqualOptionsT() {
  }
};

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualOptionsT NativeTableType;
  typedef GreaterEqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder {
  typedef GreaterEqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
  flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public flatbuffers::NativeTable {
  typedef LessOptions TableType;
  LessOptionsT() {
  }
};

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessOptionsT NativeTableType;
  typedef LessOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder {
  typedef LessOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessOptionsBuilder &operator=(const LessOptionsBuilder &);
  flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public flatbuffers::NativeTable {
  typedef LessEqualOptions TableType;
  LessEqualOptionsT() {
  }
};

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualOptionsT NativeTableType;
  typedef LessEqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder {
  typedef LessEqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
  flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public flatbuffers::NativeTable {
  typedef NegOptions TableType;
  NegOptionsT() {
  }
};

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegOptionsT NativeTableType;
  typedef NegOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NegOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder {
  typedef NegOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegOptionsBuilder &operator=(const NegOptionsBuilder &);
  flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public flatbuffers::NativeTable {
  typedef SelectOptions TableType;
  SelectOptionsT() {
  }
};

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectOptionsT NativeTableType;
  typedef SelectOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder {
  typedef SelectOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
  flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public flatbuffers::NativeTable {
  typedef SliceOptions TableType;
  SliceOptionsT() {
  }
};

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceOptionsT NativeTableType;
  typedef SliceOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder {
  typedef SliceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
  flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public flatbuffers::NativeTable {
  typedef TransposeConvOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  TransposeConvOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0) {
  }
};

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeConvOptionsT NativeTableType;
  typedef TransposeConvOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  bool mutate_padding(tflite::Padding _padding) {
    return SetField<int8_t>(VT_PADDING, static_cast<int8_t>(_padding), 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  bool mutate_stride_w(int32_t _stride_w) {
    return SetField<int32_t>(VT_STRIDE_W, _stride_w, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  bool mutate_stride_h(int32_t _stride_h) {
    return SetField<int32_t>(VT_STRIDE_H, _stride_h, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           verifier.EndTable();
  }
  TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeConvOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder {
  typedef TransposeConvOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
  flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public flatbuffers::NativeTable {
  typedef ExpandDimsOptions TableType;
  ExpandDimsOptionsT() {
  }
};

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsOptionsT NativeTableType;
  typedef ExpandDimsOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDimsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder {
  typedef ExpandDimsOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
  flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public flatbuffers::NativeTable {
  typedef SparseToDenseOptions TableType;
  bool validate_indices;
  SparseToDenseOptionsT()
      : validate_indices(false) {
  }
};

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseToDenseOptionsT NativeTableType;
  typedef SparseToDenseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const {
    return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
  }
  bool mutate_validate_indices(bool _validate_indices) {
    return SetField<uint8_t>(VT_VALIDATE_INDICES, static_cast<uint8_t>(_validate_indices), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) &&
           verifier.EndTable();
  }
  SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseToDenseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder {
  typedef SparseToDenseOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
  flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public flatbuffers::NativeTable {
  typedef EqualOptions TableType;
  EqualOptionsT() {
  }
};

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualOptionsT NativeTableType;
  typedef EqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder {
  typedef EqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
  flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public flatbuffers::NativeTable {
  typedef NotEqualOptions TableType;
  NotEqualOptionsT() {
  }
};

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualOptionsT NativeTableType;
  typedef NotEqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder {
  typedef NotEqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
  flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public flatbuffers::NativeTable {
  typedef ShapeOptions TableType;
  tflite::TensorType out_type;
  ShapeOptionsT()
      : out_type(tflite::TensorType_FLOAT32) {
  }
};

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeOptionsT NativeTableType;
  typedef ShapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_TYPE = 4
  };
  tflite::TensorType out_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool mutate_out_type(tflite::TensorType _out_type) {
    return SetField<int8_t>(VT_OUT_TYPE, static_cast<int8_t>(_out_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUT_TYPE) &&
           verifier.EndTable();
  }
  ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder {
  typedef ShapeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(tflite::TensorType out_type) {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
  flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType out_type = tflite::TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public flatbuffers::NativeTable {
  typedef PowOptions TableType;
  PowOptionsT() {
  }
};

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowOptionsT NativeTableType;
  typedef PowOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder {
  typedef PowOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionsBuilder &operator=(const PowOptionsBuilder &);
  flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public flatbuffers::NativeTable {
  typedef FakeQuantOptions TableType;
  float min;
  float max;
  int32_t num_bits;
  bool narrow_range;
  FakeQuantOptionsT()
      : min(0.0f),
        max(0.0f),
        num_bits(0),
        narrow_range(false) {
  }
};

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantOptionsT NativeTableType;
  typedef FakeQuantOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  bool mutate_min(float _min) {
    return SetField<float>(VT_MIN, _min, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool mutate_max(float _max) {
    return SetField<float>(VT_MAX, _max, 0.0f);
  }
  int32_t num_bits() const {
    return GetField<int32_t>(VT_NUM_BITS, 0);
  }
  bool mutate_num_bits(int32_t _num_bits) {
    return SetField<int32_t>(VT_NUM_BITS, _num_bits, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool mutate_narrow_range(bool _narrow_range) {
    return SetField<uint8_t>(VT_NARROW_RANGE, static_cast<uint8_t>(_narrow_range), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
  FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder {
  typedef FakeQuantOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
  flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int32_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public flatbuffers::NativeTable {
  typedef PackOptions TableType;
  int32_t values_count;
  int32_t axis;
  PackOptionsT()
      : values_count(0),
        axis(0) {
  }
};

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PackOptionsT NativeTableType;
  typedef PackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const {
    return GetField<int32_t>(VT_VALUES_COUNT, 0);
  }
  bool mutate_values_count(int32_t _values_count) {
    return SetField<int32_t>(VT_VALUES_COUNT, _values_count, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder {
  typedef PackOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
  }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackOptionsBuilder &operator=(const PackOptionsBuilder &);
  flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public flatbuffers::NativeTable {
  typedef LogicalOrOptions TableType;
  LogicalOrOptionsT() {
  }
};

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalOrOptionsT NativeTableType;
  typedef LogicalOrOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalOrOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder {
  typedef LogicalOrOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
  flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public flatbuffers::NativeTable {
  typedef OneHotOptions TableType;
  int32_t axis;
  OneHotOptionsT()
      : axis(0) {
  }
};

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotOptionsT NativeTableType;
  typedef OneHotOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder {
  typedef OneHotOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
  }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
  flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsOptionsT : public flatbuffers::NativeTable {
  typedef AbsOptions TableType;
  AbsOptionsT() {
  }
};

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsOptionsT NativeTableType;
  typedef AbsOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionsBuilder {
  typedef AbsOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionsBuilder &operator=(const AbsOptionsBuilder &);
  flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public flatbuffers::NativeTable {
  typedef LogicalAndOptions TableType;
  LogicalAndOptionsT() {
  }
};

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalAndOptionsT NativeTableType;
  typedef LogicalAndOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalAndOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder {
  typedef LogicalAndOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
  flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public flatbuffers::NativeTable {
  typedef LogicalNotOptions TableType;
  LogicalNotOptionsT() {
  }
};

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalNotOptionsT NativeTableType;
  typedef LogicalNotOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalNotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder {
  typedef LogicalNotOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
  flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public flatbuffers::NativeTable {
  typedef UnpackOptions TableType;
  int32_t num;
  int32_t axis;
  UnpackOptionsT()
      : num(0),
        axis(0) {
  }
};

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnpackOptionsT NativeTableType;
  typedef UnpackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  bool mutate_num(int32_t _num) {
    return SetField<int32_t>(VT_NUM, _num, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnpackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder {
  typedef UnpackOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
  }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
  flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public flatbuffers::NativeTable {
  typedef FloorDivOptions TableType;
  FloorDivOptionsT() {
  }
};

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorDivOptionsT NativeTableType;
  typedef FloorDivOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorDivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder {
  typedef FloorDivOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
  flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public flatbuffers::NativeTable {
  typedef SquareOptions TableType;
  SquareOptionsT() {
  }
};

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareOptionsT NativeTableType;
  typedef SquareOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder {
  typedef SquareOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
  flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public flatbuffers::NativeTable {
  typedef ZerosLikeOptions TableType;
  ZerosLikeOptionsT() {
  }
};

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ZerosLikeOptionsT NativeTableType;
  typedef ZerosLikeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ZerosLikeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder {
  typedef ZerosLikeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
  flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public flatbuffers::NativeTable {
  typedef FillOptions TableType;
  FillOptionsT() {
  }
};

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillOptionsT NativeTableType;
  typedef FillOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FillOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder {
  typedef FillOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillOptionsBuilder &operator=(const FillOptionsBuilder &);
  flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModOptionsT : public flatbuffers::NativeTable {
  typedef FloorModOptions TableType;
  FloorModOptionsT() {
  }
};

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorModOptionsT NativeTableType;
  typedef FloorModOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorModOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorModOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModOptionsBuilder {
  typedef FloorModOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModOptionsBuilder &operator=(const FloorModOptionsBuilder &);
  flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeOptionsT : public flatbuffers::NativeTable {
  typedef RangeOptions TableType;
  RangeOptionsT() {
  }
};

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeOptionsT NativeTableType;
  typedef RangeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RangeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RangeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeOptionsBuilder {
  typedef RangeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeOptionsBuilder &operator=(const RangeOptionsBuilder &);
  flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionsT : public flatbuffers::NativeTable {
  typedef LeakyReluOptions TableType;
  float alpha;
  LeakyReluOptionsT()
      : alpha(0.0f) {
  }
};

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluOptionsT NativeTableType;
  typedef LeakyReluOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  LeakyReluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionsBuilder {
  typedef LeakyReluOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionsBuilder &operator=(const LeakyReluOptionsBuilder &);
  flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceOptionsT : public flatbuffers::NativeTable {
  typedef SquaredDifferenceOptions TableType;
  SquaredDifferenceOptionsT() {
  }
};

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquaredDifferenceOptionsT NativeTableType;
  typedef SquaredDifferenceOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquaredDifferenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquaredDifferenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceOptionsBuilder {
  typedef SquaredDifferenceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceOptionsBuilder &operator=(const SquaredDifferenceOptionsBuilder &);
  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorPadOptionsT : public flatbuffers::NativeTable {
  typedef MirrorPadOptions TableType;
  tflite::MirrorPadMode mode;
  MirrorPadOptionsT()
      : mode(tflite::MirrorPadMode_REFLECT) {
  }
};

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MirrorPadOptionsT NativeTableType;
  typedef MirrorPadOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  tflite::MirrorPadMode mode() const {
    return static_cast<tflite::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool mutate_mode(tflite::MirrorPadMode _mode) {
    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  MirrorPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MirrorPadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorPadOptionsBuilder {
  typedef MirrorPadOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(tflite::MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MirrorPadOptionsBuilder &operator=(const MirrorPadOptionsBuilder &);
  flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public flatbuffers::NativeTable {
  typedef OperatorCode TableType;
  tflite::BuiltinOperator builtin_code;
  std::string custom_code;
  int32_t version;
  OperatorCodeT()
      : builtin_code(tflite::BuiltinOperator_ADD),
        version(1) {
  }
};

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorCodeT NativeTableType;
  typedef OperatorCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8
  };
  tflite::BuiltinOperator builtin_code() const {
    return static_cast<tflite::BuiltinOperator>(GetField<int8_t>(VT_BUILTIN_CODE, 0));
  }
  bool mutate_builtin_code(tflite::BuiltinOperator _builtin_code) {
    return SetField<int8_t>(VT_BUILTIN_CODE, static_cast<int8_t>(_builtin_code), 0);
  }
  const flatbuffers::String *custom_code() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  flatbuffers::String *mutable_custom_code() {
    return GetPointer<flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 1);
  }
  bool mutate_version(int32_t _version) {
    return SetField<int32_t>(VT_VERSION, _version, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BUILTIN_CODE) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
  OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder {
  typedef OperatorCode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_builtin_code(tflite::BuiltinOperator builtin_code) {
    fbb_.AddElement<int8_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int8_t>(builtin_code), 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
  flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0,
    int32_t version = 1) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_builtin_code(builtin_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD,
    const char *custom_code = nullptr,
    int32_t version = 1) {
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return tflite::CreateOperatorCode(
      _fbb,
      builtin_code,
      custom_code__,
      version);
}

flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public flatbuffers::NativeTable {
  typedef Operator TableType;
  uint32_t opcode_index;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  tflite::BuiltinOptionsUnion builtin_options;
  std::vector<uint8_t> custom_options;
  tflite::CustomOptionsFormat custom_options_format;
  std::vector<bool> mutating_variable_inputs;
  OperatorT()
      : opcode_index(0),
        custom_options_format(tflite::CustomOptionsFormat_FLEXBUFFERS) {
  }
};

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorT NativeTableType;
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18
  };
  uint32_t opcode_index() const {
    return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
  }
  bool mutate_opcode_index(uint32_t _opcode_index) {
    return SetField<uint32_t>(VT_OPCODE_INDEX, _opcode_index, 0);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  tflite::BuiltinOptions builtin_options_type() const {
    return static_cast<tflite::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const {
    return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
  }
  template<typename T> const T *builtin_options_as() const;
  const tflite::Conv2DOptions *builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv2DOptions ? static_cast<const tflite::Conv2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DepthwiseConv2DOptions ? static_cast<const tflite::DepthwiseConv2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatEmbeddingsOptions ? static_cast<const tflite::ConcatEmbeddingsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSHProjectionOptions ? static_cast<const tflite::LSHProjectionOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Pool2DOptions *builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Pool2DOptions ? static_cast<const tflite::Pool2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SVDFOptions *builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SVDFOptions ? static_cast<const tflite::SVDFOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RNNOptions *builtin_options_as_RNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RNNOptions ? static_cast<const tflite::RNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FullyConnectedOptions ? static_cast<const tflite::FullyConnectedOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SoftmaxOptions ? static_cast<const tflite::SoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatenationOptions ? static_cast<const tflite::ConcatenationOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AddOptions *builtin_options_as_AddOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddOptions ? static_cast<const tflite::AddOptions *>(builtin_options()) : nullptr;
  }
  const tflite::L2NormOptions *builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_L2NormOptions ? static_cast<const tflite::L2NormOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LocalResponseNormalizationOptions ? static_cast<const tflite::LocalResponseNormalizationOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LSTMOptions *builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSTMOptions ? static_cast<const tflite::LSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ResizeBilinearOptions ? static_cast<const tflite::ResizeBilinearOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CallOptions *builtin_options_as_CallOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOptions ? static_cast<const tflite::CallOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReshapeOptions *builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReshapeOptions ? static_cast<const tflite::ReshapeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SkipGramOptions *builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SkipGramOptions ? static_cast<const tflite::SkipGramOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToDepthOptions ? static_cast<const tflite::SpaceToDepthOptions *>(builtin_options()) : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EmbeddingLookupSparseOptions ? static_cast<const tflite::EmbeddingLookupSparseOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MulOptions *builtin_options_as_MulOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MulOptions ? static_cast<const tflite::MulOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PadOptions *builtin_options_as_PadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadOptions ? static_cast<const tflite::PadOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GatherOptions *builtin_options_as_GatherOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherOptions ? static_cast<const tflite::GatherOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BatchToSpaceNDOptions ? static_cast<const tflite::BatchToSpaceNDOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToBatchNDOptions ? static_cast<const tflite::SpaceToBatchNDOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TransposeOptions *builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeOptions ? static_cast<const tflite::TransposeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReducerOptions *builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReducerOptions ? static_cast<const tflite::ReducerOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SubOptions *builtin_options_as_SubOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SubOptions ? static_cast<const tflite::SubOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DivOptions *builtin_options_as_DivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DivOptions ? static_cast<const tflite::DivOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SqueezeOptions *builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SqueezeOptions ? static_cast<const tflite::SqueezeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SequenceRNNOptions ? static_cast<const tflite::SequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_StridedSliceOptions ? static_cast<const tflite::StridedSliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ExpOptions *builtin_options_as_ExpOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpOptions ? static_cast<const tflite::ExpOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TopKV2Options *builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_TopKV2Options ? static_cast<const tflite::TopKV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::SplitOptions *builtin_options_as_SplitOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitOptions ? static_cast<const tflite::SplitOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogSoftmaxOptions ? static_cast<const tflite::LogSoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CastOptions *builtin_options_as_CastOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CastOptions ? static_cast<const tflite::CastOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DequantizeOptions *builtin_options_as_DequantizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DequantizeOptions ? static_cast<const tflite::DequantizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MaximumMinimumOptions ? static_cast<const tflite::MaximumMinimumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMaxOptions ? static_cast<const tflite::ArgMaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LessOptions *builtin_options_as_LessOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessOptions ? static_cast<const tflite::LessOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NegOptions *builtin_options_as_NegOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NegOptions ? static_cast<const tflite::NegOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PadV2Options *builtin_options_as_PadV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadV2Options ? static_cast<const tflite::PadV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::GreaterOptions *builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterOptions ? static_cast<const tflite::GreaterOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterEqualOptions ? static_cast<const tflite::GreaterEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LessEqualOptions *builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessEqualOptions ? static_cast<const tflite::LessEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SelectOptions *builtin_options_as_SelectOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectOptions ? static_cast<const tflite::SelectOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SliceOptions *builtin_options_as_SliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SliceOptions ? static_cast<const tflite::SliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeConvOptions ? static_cast<const tflite::TransposeConvOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SparseToDenseOptions ? static_cast<const tflite::SparseToDenseOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TileOptions *builtin_options_as_TileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TileOptions ? static_cast<const tflite::TileOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpandDimsOptions ? static_cast<const tflite::ExpandDimsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::EqualOptions *builtin_options_as_EqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EqualOptions ? static_cast<const tflite::EqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NotEqualOptions *builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NotEqualOptions ? static_cast<const tflite::NotEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ShapeOptions *builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ShapeOptions ? static_cast<const tflite::ShapeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PowOptions *builtin_options_as_PowOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PowOptions ? static_cast<const tflite::PowOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ArgMinOptions *builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMinOptions ? static_cast<const tflite::ArgMinOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FakeQuantOptions ? static_cast<const tflite::FakeQuantOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PackOptions *builtin_options_as_PackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PackOptions ? static_cast<const tflite::PackOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalOrOptions ? static_cast<const tflite::LogicalOrOptions *>(builtin_options()) : nullptr;
  }
  const tflite::OneHotOptions *builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_OneHotOptions ? static_cast<const tflite::OneHotOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalAndOptions ? static_cast<const tflite::LogicalAndOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalNotOptions ? static_cast<const tflite::LogicalNotOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnpackOptions *builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnpackOptions ? static_cast<const tflite::UnpackOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FloorDivOptions *builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorDivOptions ? static_cast<const tflite::FloorDivOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SquareOptions *builtin_options_as_SquareOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquareOptions ? static_cast<const tflite::SquareOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ZerosLikeOptions ? static_cast<const tflite::ZerosLikeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FillOptions *builtin_options_as_FillOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FillOptions ? static_cast<const tflite::FillOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceLSTMOptions ? static_cast<const tflite::BidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceRNNOptions ? static_cast<const tflite::BidirectionalSequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnidirectionalSequenceLSTMOptions ? static_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FloorModOptions *builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorModOptions ? static_cast<const tflite::FloorModOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RangeOptions *builtin_options_as_RangeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RangeOptions ? static_cast<const tflite::RangeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ResizeNearestNeighborOptions ? static_cast<const tflite::ResizeNearestNeighborOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LeakyReluOptions ? static_cast<const tflite::LeakyReluOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquaredDifferenceOptions ? static_cast<const tflite::SquaredDifferenceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MirrorPadOptions ? static_cast<const tflite::MirrorPadOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AbsOptions *builtin_options_as_AbsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AbsOptions ? static_cast<const tflite::AbsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SplitVOptions *builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitVOptions ? static_cast<const tflite::SplitVOptions *>(builtin_options()) : nullptr;
  }
  void *mutable_builtin_options() {
    return GetPointer<void *>(VT_BUILTIN_OPTIONS);
  }
  const flatbuffers::Vector<uint8_t> *custom_options() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  flatbuffers::Vector<uint8_t> *mutable_custom_options() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  tflite::CustomOptionsFormat custom_options_format() const {
    return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  bool mutate_custom_options_format(tflite::CustomOptionsFormat _custom_options_format) {
    return SetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(_custom_options_format), 0);
  }
  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  flatbuffers::Vector<uint8_t> *mutable_mutating_variable_inputs() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           verifier.EndTable();
  }
  OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Operator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::Conv2DOptions *Operator::builtin_options_as<tflite::Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template<> inline const tflite::DepthwiseConv2DOptions *Operator::builtin_options_as<tflite::DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template<> inline const tflite::ConcatEmbeddingsOptions *Operator::builtin_options_as<tflite::ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template<> inline const tflite::LSHProjectionOptions *Operator::builtin_options_as<tflite::LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template<> inline const tflite::Pool2DOptions *Operator::builtin_options_as<tflite::Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template<> inline const tflite::SVDFOptions *Operator::builtin_options_as<tflite::SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template<> inline const tflite::RNNOptions *Operator::builtin_options_as<tflite::RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template<> inline const tflite::FullyConnectedOptions *Operator::builtin_options_as<tflite::FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template<> inline const tflite::SoftmaxOptions *Operator::builtin_options_as<tflite::SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template<> inline const tflite::ConcatenationOptions *Operator::builtin_options_as<tflite::ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template<> inline const tflite::AddOptions *Operator::builtin_options_as<tflite::AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template<> inline const tflite::L2NormOptions *Operator::builtin_options_as<tflite::L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template<> inline const tflite::LocalResponseNormalizationOptions *Operator::builtin_options_as<tflite::LocalResponseNormalizationOptions>() const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template<> inline const tflite::LSTMOptions *Operator::builtin_options_as<tflite::LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template<> inline const tflite::ResizeBilinearOptions *Operator::builtin_options_as<tflite::ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template<> inline const tflite::CallOptions *Operator::builtin_options_as<tflite::CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template<> inline const tflite::ReshapeOptions *Operator::builtin_options_as<tflite::ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template<> inline const tflite::SkipGramOptions *Operator::builtin_options_as<tflite::SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template<> inline const tflite::SpaceToDepthOptions *Operator::builtin_options_as<tflite::SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template<> inline const tflite::EmbeddingLookupSparseOptions *Operator::builtin_options_as<tflite::EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template<> inline const tflite::MulOptions *Operator::builtin_options_as<tflite::MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template<> inline const tflite::PadOptions *Operator::builtin_options_as<tflite::PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template<> inline const tflite::GatherOptions *Operator::builtin_options_as<tflite::GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template<> inline const tflite::BatchToSpaceNDOptions *Operator::builtin_options_as<tflite::BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template<> inline const tflite::SpaceToBatchNDOptions *Operator::builtin_options_as<tflite::SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template<> inline const tflite::TransposeOptions *Operator::builtin_options_as<tflite::TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template<> inline const tflite::ReducerOptions *Operator::builtin_options_as<tflite::ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template<> inline const tflite::SubOptions *Operator::builtin_options_as<tflite::SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template<> inline const tflite::DivOptions *Operator::builtin_options_as<tflite::DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template<> inline const tflite::SqueezeOptions *Operator::builtin_options_as<tflite::SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template<> inline const tflite::SequenceRNNOptions *Operator::builtin_options_as<tflite::SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template<> inline const tflite::StridedSliceOptions *Operator::builtin_options_as<tflite::StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template<> inline const tflite::ExpOptions *Operator::builtin_options_as<tflite::ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template<> inline const tflite::TopKV2Options *Operator::builtin_options_as<tflite::TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template<> inline const tflite::SplitOptions *Operator::builtin_options_as<tflite::SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template<> inline const tflite::LogSoftmaxOptions *Operator::builtin_options_as<tflite::LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template<> inline const tflite::CastOptions *Operator::builtin_options_as<tflite::CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template<> inline const tflite::DequantizeOptions *Operator::builtin_options_as<tflite::DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template<> inline const tflite::MaximumMinimumOptions *Operator::builtin_options_as<tflite::MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template<> inline const tflite::ArgMaxOptions *Operator::builtin_options_as<tflite::ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template<> inline const tflite::LessOptions *Operator::builtin_options_as<tflite::LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template<> inline const tflite::NegOptions *Operator::builtin_options_as<tflite::NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template<> inline const tflite::PadV2Options *Operator::builtin_options_as<tflite::PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template<> inline const tflite::GreaterOptions *Operator::builtin_options_as<tflite::GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template<> inline const tflite::GreaterEqualOptions *Operator::builtin_options_as<tflite::GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template<> inline const tflite::LessEqualOptions *Operator::builtin_options_as<tflite::LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template<> inline const tflite::SelectOptions *Operator::builtin_options_as<tflite::SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template<> inline const tflite::SliceOptions *Operator::builtin_options_as<tflite::SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template<> inline const tflite::TransposeConvOptions *Operator::builtin_options_as<tflite::TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template<> inline const tflite::SparseToDenseOptions *Operator::builtin_options_as<tflite::SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template<> inline const tflite::TileOptions *Operator::builtin_options_as<tflite::TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template<> inline const tflite::ExpandDimsOptions *Operator::builtin_options_as<tflite::ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template<> inline const tflite::EqualOptions *Operator::builtin_options_as<tflite::EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template<> inline const tflite::NotEqualOptions *Operator::builtin_options_as<tflite::NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template<> inline const tflite::ShapeOptions *Operator::builtin_options_as<tflite::ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template<> inline const tflite::PowOptions *Operator::builtin_options_as<tflite::PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template<> inline const tflite::ArgMinOptions *Operator::builtin_options_as<tflite::ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template<> inline const tflite::FakeQuantOptions *Operator::builtin_options_as<tflite::FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template<> inline const tflite::PackOptions *Operator::builtin_options_as<tflite::PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template<> inline const tflite::LogicalOrOptions *Operator::builtin_options_as<tflite::LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template<> inline const tflite::OneHotOptions *Operator::builtin_options_as<tflite::OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template<> inline const tflite::LogicalAndOptions *Operator::builtin_options_as<tflite::LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template<> inline const tflite::LogicalNotOptions *Operator::builtin_options_as<tflite::LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template<> inline const tflite::UnpackOptions *Operator::builtin_options_as<tflite::UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template<> inline const tflite::FloorDivOptions *Operator::builtin_options_as<tflite::FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template<> inline const tflite::SquareOptions *Operator::builtin_options_as<tflite::SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template<> inline const tflite::ZerosLikeOptions *Operator::builtin_options_as<tflite::ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template<> inline const tflite::FillOptions *Operator::builtin_options_as<tflite::FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template<> inline const tflite::BidirectionalSequenceLSTMOptions *Operator::builtin_options_as<tflite::BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template<> inline const tflite::BidirectionalSequenceRNNOptions *Operator::builtin_options_as<tflite::BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template<> inline const tflite::UnidirectionalSequenceLSTMOptions *Operator::builtin_options_as<tflite::UnidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template<> inline const tflite::FloorModOptions *Operator::builtin_options_as<tflite::FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template<> inline const tflite::RangeOptions *Operator::builtin_options_as<tflite::RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template<> inline const tflite::ResizeNearestNeighborOptions *Operator::builtin_options_as<tflite::ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template<> inline const tflite::LeakyReluOptions *Operator::builtin_options_as<tflite::LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template<> inline const tflite::SquaredDifferenceOptions *Operator::builtin_options_as<tflite::SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template<> inline const tflite::MirrorPadOptions *Operator::builtin_options_as<tflite::MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template<> inline const tflite::AbsOptions *Operator::builtin_options_as<tflite::AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template<> inline const tflite::SplitVOptions *Operator::builtin_options_as<tflite::SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

struct OperatorBuilder {
  typedef Operator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(tflite::CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorBuilder &operator=(const OperatorBuilder &);
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    const std::vector<uint8_t> *custom_options = nullptr,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ = mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
  return tflite::CreateOperator(
      _fbb,
      opcode_index,
      inputs__,
      outputs__,
      builtin_options_type,
      builtin_options,
      custom_options__,
      custom_options_format,
      mutating_variable_inputs__);
}

flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
  typedef SubGraph TableType;
  std::vector<std::unique_ptr<tflite::TensorT>> tensors;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  std::vector<std::unique_ptr<tflite::OperatorT>> operators;
  std::string name;
  SubGraphT() {
  }
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphT NativeTableType;
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);
  }
  flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *mutable_tensors() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);
  }
  flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *mutable_operators() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder &operator=(const SubGraphBuilder &);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Operator>> *operators = nullptr,
    const char *name = nullptr) {
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateSubGraph(
      _fbb,
      tensors__,
      inputs__,
      outputs__,
      operators__,
      name__);
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public flatbuffers::NativeTable {
  typedef Buffer TableType;
  std::vector<uint8_t> data;
  BufferT() {
  }
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferT NativeTableType;
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
  typedef Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::CreateBuffer(
      _fbb,
      data__);
}

flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
  typedef Model TableType;
  uint32_t version;
  std::vector<std::unique_ptr<tflite::OperatorCodeT>> operator_codes;
  std::vector<std::unique_ptr<tflite::SubGraphT>> subgraphs;
  std::string description;
  std::vector<std::unique_ptr<tflite::BufferT>> buffers;
  std::vector<int32_t> metadata_buffer;
  ModelT()
      : version(0) {
  }
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelT NativeTableType;
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);
  }
  flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *mutable_operator_codes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);
  }
  flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *mutable_subgraphs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  flatbuffers::String *mutable_description() {
    return GetPointer<flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *mutable_buffers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);
  }
  const flatbuffers::Vector<int32_t> *metadata_buffer() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  flatbuffers::Vector<int32_t> *mutable_metadata_buffer() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) &&
           verifier.VerifyVector(metadata_buffer()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  typedef Model Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  void add_operator_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers) {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Buffer>> *buffers = nullptr,
    const std::vector<int32_t> *metadata_buffer = nullptr) {
  auto operator_codes__ = operator_codes ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;
  auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  return tflite::CreateModel(
      _fbb,
      version,
      operator_codes__,
      subgraphs__,
      description__,
      buffers__,
      metadata_buffer__);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CustomQuantizationT *CustomQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::CustomQuantizationT> _o = std::unique_ptr<tflite::CustomQuantizationT>(new CustomQuantizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = custom(); if (_e) { _o->custom.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->custom[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomQuantization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomQuantizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->custom.size(), sizeof(uint8_t), 16);
  auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      _custom);
}

inline QuantizationParametersT *QuantizationParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::QuantizationParametersT> _o = std::unique_ptr<tflite::QuantizationParametersT>(new QuantizationParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); if (_e) { _o->min.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min[_i] = _e->Get(_i); } } }
  { auto _e = max(); if (_e) { _o->max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max[_i] = _e->Get(_i); } } }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
  { auto _e = zero_point(); if (_e) { _o->zero_point.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero_point[_i] = _e->Get(_i); } } }
  { auto _e = details_type(); _o->details.type = _e; }
  { auto _e = details(); if (_e) _o->details.value = tflite::QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver); }
}

inline flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizationParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
  auto _max = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _zero_point = _o->zero_point.size() ? _fbb.CreateVector(_o->zero_point) : 0;
  auto _details_type = _o->details.type;
  auto _details = _o->details.Pack(_fbb);
  return tflite::CreateQuantizationParameters(
      _fbb,
      _min,
      _max,
      _scale,
      _zero_point,
      _details_type,
      _details);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::TensorT> _o = std::unique_ptr<tflite::TensorT>(new TensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = buffer(); _o->buffer = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = quantization(); if (_e) _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver)); }
  { auto _e = is_variable(); _o->is_variable = _e; }
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _buffer = _o->buffer;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _quantization = _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
  auto _is_variable = _o->is_variable;
  return tflite::CreateTensor(
      _fbb,
      _shape,
      _type,
      _buffer,
      _name,
      _quantization,
      _is_variable);
}

inline Conv2DOptionsT *Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::Conv2DOptionsT> _o = std::unique_ptr<tflite::Conv2DOptionsT>(new Conv2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline Pool2DOptionsT *Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::Pool2DOptionsT> _o = std::unique_ptr<tflite::Pool2DOptionsT>(new Pool2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = filter_width(); _o->filter_width = _e; }
  { auto _e = filter_height(); _o->filter_height = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _filter_width = _o->filter_width;
  auto _filter_height = _o->filter_height;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreatePool2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _filter_width,
      _filter_height,
      _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::DepthwiseConv2DOptionsT> _o = std::unique_ptr<tflite::DepthwiseConv2DOptionsT>(new DepthwiseConv2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = depth_multiplier(); _o->depth_multiplier = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _depth_multiplier = _o->depth_multiplier;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateDepthwiseConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _depth_multiplier,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ConcatEmbeddingsOptionsT> _o = std::unique_ptr<tflite::ConcatEmbeddingsOptionsT>(new ConcatEmbeddingsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_channels(); _o->num_channels = _e; }
  { auto _e = num_columns_per_channel(); if (_e) { _o->num_columns_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->num_columns_per_channel[_i] = _e->Get(_i); } } }
  { auto _e = embedding_dim_per_channel(); if (_e) { _o->embedding_dim_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_dim_per_channel[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatEmbeddingsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_channels = _o->num_channels;
  auto _num_columns_per_channel = _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
  auto _embedding_dim_per_channel = _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      _num_channels,
      _num_columns_per_channel,
      _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LSHProjectionOptionsT> _o = std::unique_ptr<tflite::LSHProjectionOptionsT>(new LSHProjectionOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSHProjectionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return tflite::CreateLSHProjectionOptions(
      _fbb,
      _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SVDFOptionsT> _o = std::unique_ptr<tflite::SVDFOptionsT>(new SVDFOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rank(); _o->rank = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SVDFOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rank = _o->rank;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateSVDFOptions(
      _fbb,
      _rank,
      _fused_activation_function);
}

inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::RNNOptionsT> _o = std::unique_ptr<tflite::RNNOptionsT>(new RNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<RNNOptions> RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateRNNOptions(
      _fbb,
      _fused_activation_function);
}

inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SequenceRNNOptionsT> _o = std::unique_ptr<tflite::SequenceRNNOptionsT>(new SequenceRNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function);
}

inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::BidirectionalSequenceRNNOptionsT> _o = std::unique_ptr<tflite::BidirectionalSequenceRNNOptionsT>(new BidirectionalSequenceRNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = merge_outputs(); _o->merge_outputs = _e; }
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _merge_outputs = _o->merge_outputs;
  return tflite::CreateBidirectionalSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _merge_outputs);
}

inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::FullyConnectedOptionsT> _o = std::unique_ptr<tflite::FullyConnectedOptionsT>(new FullyConnectedOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = weights_format(); _o->weights_format = _e; }
}

inline flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullyConnectedOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _weights_format = _o->weights_format;
  return tflite::CreateFullyConnectedOptions(
      _fbb,
      _fused_activation_function,
      _weights_format);
}

inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SoftmaxOptionsT> _o = std::unique_ptr<tflite::SoftmaxOptionsT>(new SoftmaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return tflite::CreateSoftmaxOptions(
      _fbb,
      _beta);
}

inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ConcatenationOptionsT> _o = std::unique_ptr<tflite::ConcatenationOptionsT>(new ConcatenationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatenationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateConcatenationOptions(
      _fbb,
      _axis,
      _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::AddOptionsT> _o = std::unique_ptr<tflite::AddOptionsT>(new AddOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddOptions::UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<AddOptions> AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateAddOptions(
      _fbb,
      _fused_activation_function);
}

inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::MulOptionsT> _o = std::unique_ptr<tflite::MulOptionsT>(new MulOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulOptions::UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<MulOptions> MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateMulOptions(
      _fbb,
      _fused_activation_function);
}

inline L2NormOptionsT *L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::L2NormOptionsT> _o = std::unique_ptr<tflite::L2NormOptionsT>(new L2NormOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateL2NormOptions(
      _fbb,
      _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LocalResponseNormalizationOptionsT> _o = std::unique_ptr<tflite::LocalResponseNormalizationOptionsT>(new LocalResponseNormalizationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = bias(); _o->bias = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _radius = _o->radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return tflite::CreateLocalResponseNormalizationOptions(
      _fbb,
      _radius,
      _bias,
      _alpha,
      _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LSTMOptionsT> _o = std::unique_ptr<tflite::LSTMOptionsT>(new LSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = kernel_type(); _o->kernel_type = _e; }
}

inline flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _kernel_type = _o->kernel_type;
  return tflite::CreateLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _kernel_type);
}

inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::UnidirectionalSequenceLSTMOptionsT> _o = std::unique_ptr<tflite::UnidirectionalSequenceLSTMOptionsT>(new UnidirectionalSequenceLSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = time_major(); _o->time_major = _e; }
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _time_major = _o->time_major;
  return tflite::CreateUnidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _time_major);
}

inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::BidirectionalSequenceLSTMOptionsT> _o = std::unique_ptr<tflite::BidirectionalSequenceLSTMOptionsT>(new BidirectionalSequenceLSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = merge_outputs(); _o->merge_outputs = _e; }
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _merge_outputs = _o->merge_outputs;
  return tflite::CreateBidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _merge_outputs);
}

inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ResizeBilinearOptionsT> _o = std::unique_ptr<tflite::ResizeBilinearOptionsT>(new ResizeBilinearOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; }
}

inline flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeBilinearOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  return tflite::CreateResizeBilinearOptions(
      _fbb,
      _align_corners);
}

inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ResizeNearestNeighborOptionsT> _o = std::unique_ptr<tflite::ResizeNearestNeighborOptionsT>(new ResizeNearestNeighborOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; }
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeNearestNeighborOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  return tflite::CreateResizeNearestNeighborOptions(
      _fbb,
      _align_corners);
}

inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::CallOptionsT> _o = std::unique_ptr<tflite::CallOptionsT>(new CallOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallOptions::UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subgraph(); _o->subgraph = _e; }
}

inline flatbuffers::Offset<CallOptions> CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subgraph = _o->subgraph;
  return tflite::CreateCallOptions(
      _fbb,
      _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::PadOptionsT> _o = std::unique_ptr<tflite::PadOptionsT>(new PadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadOptions::UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadOptions> PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadOptions(
      _fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::PadV2OptionsT> _o = std::unique_ptr<tflite::PadV2OptionsT>(new PadV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadV2Options> PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadV2Options(
      _fbb);
}

inline ReshapeOptionsT *ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ReshapeOptionsT> _o = std::unique_ptr<tflite::ReshapeOptionsT>(new ReshapeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_shape(); if (_e) { _o->new_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_shape[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      _new_shape);
}

inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SpaceToBatchNDOptionsT> _o = std::unique_ptr<tflite::SpaceToBatchNDOptionsT>(new SpaceToBatchNDOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSpaceToBatchNDOptions(
      _fbb);
}

inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::BatchToSpaceNDOptionsT> _o = std::unique_ptr<tflite::BatchToSpaceNDOptionsT>(new BatchToSpaceNDOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBatchToSpaceNDOptions(
      _fbb);
}

inline SkipGramOptionsT *SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SkipGramOptionsT> _o = std::unique_ptr<tflite::SkipGramOptionsT>(new SkipGramOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ngram_size(); _o->ngram_size = _e; }
  { auto _e = max_skip_size(); _o->max_skip_size = _e; }
  { auto _e = include_all_ngrams(); _o->include_all_ngrams = _e; }
}

inline flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ngram_size = _o->ngram_size;
  auto _max_skip_size = _o->max_skip_size;
  auto _include_all_ngrams = _o->include_all_ngrams;
  return tflite::CreateSkipGramOptions(
      _fbb,
      _ngram_size,
      _max_skip_size,
      _include_all_ngrams);
}

inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SpaceToDepthOptionsT> _o = std::unique_ptr<tflite::SpaceToDepthOptionsT>(new SpaceToDepthOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
}

inline flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateSpaceToDepthOptions(
      _fbb,
      _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SubOptionsT> _o = std::unique_ptr<tflite::SubOptionsT>(new SubOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubOptions::UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<SubOptions> SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateSubOptions(
      _fbb,
      _fused_activation_function);
}

inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::DivOptionsT> _o = std::unique_ptr<tflite::DivOptionsT>(new DivOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivOptions::UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<DivOptions> DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateDivOptions(
      _fbb,
      _fused_activation_function);
}

inline TopKV2OptionsT *TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::TopKV2OptionsT> _o = std::unique_ptr<tflite::TopKV2OptionsT>(new TopKV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTopKV2Options(
      _fbb);
}

inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::EmbeddingLookupSparseOptionsT> _o = std::unique_ptr<tflite::EmbeddingLookupSparseOptionsT>(new EmbeddingLookupSparseOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = combiner(); _o->combiner = _e; }
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _combiner = _o->combiner;
  return tflite::CreateEmbeddingLookupSparseOptions(
      _fbb,
      _combiner);
}

inline GatherOptionsT *GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::GatherOptionsT> _o = std::unique_ptr<tflite::GatherOptionsT>(new GatherOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<GatherOptions> GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return tflite::CreateGatherOptions(
      _fbb,
      _axis);
}

inline TransposeOptionsT *TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::TransposeOptionsT> _o = std::unique_ptr<tflite::TransposeOptionsT>(new TransposeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTransposeOptions(
      _fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ExpOptionsT> _o = std::unique_ptr<tflite::ExpOptionsT>(new ExpOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpOptions> ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpOptions(
      _fbb);
}

inline ReducerOptionsT *ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ReducerOptionsT> _o = std::unique_ptr<tflite::ReducerOptionsT>(new ReducerOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_dims(); _o->keep_dims = _e; }
}

inline flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReducerOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_dims = _o->keep_dims;
  return tflite::CreateReducerOptions(
      _fbb,
      _keep_dims);
}

inline SqueezeOptionsT *SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SqueezeOptionsT> _o = std::unique_ptr<tflite::SqueezeOptionsT>(new SqueezeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      _squeeze_dims);
}

inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SplitOptionsT> _o = std::unique_ptr<tflite::SplitOptionsT>(new SplitOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; }
}

inline flatbuffers::Offset<SplitOptions> SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitOptions(
      _fbb,
      _num_splits);
}

inline SplitVOptionsT *SplitVOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SplitVOptionsT> _o = std::unique_ptr<tflite::SplitVOptionsT>(new SplitVOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; }
}

inline flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitVOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitVOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitVOptions(
      _fbb,
      _num_splits);
}

inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::StridedSliceOptionsT> _o = std::unique_ptr<tflite::StridedSliceOptionsT>(new StridedSliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_mask(); _o->begin_mask = _e; }
  { auto _e = end_mask(); _o->end_mask = _e; }
  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
}

inline flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  return tflite::CreateStridedSliceOptions(
      _fbb,
      _begin_mask,
      _end_mask,
      _ellipsis_mask,
      _new_axis_mask,
      _shrink_axis_mask);
}

inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LogSoftmaxOptionsT> _o = std::unique_ptr<tflite::LogSoftmaxOptionsT>(new LogSoftmaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogSoftmaxOptions(
      _fbb);
}

inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::CastOptionsT> _o = std::unique_ptr<tflite::CastOptionsT>(new CastOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CastOptions::UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = in_data_type(); _o->in_data_type = _e; }
  { auto _e = out_data_type(); _o->out_data_type = _e; }
}

inline flatbuffers::Offset<CastOptions> CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _in_data_type = _o->in_data_type;
  auto _out_data_type = _o->out_data_type;
  return tflite::CreateCastOptions(
      _fbb,
      _in_data_type,
      _out_data_type);
}

inline DequantizeOptionsT *DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::DequantizeOptionsT> _o = std::unique_ptr<tflite::DequantizeOptionsT>(new DequantizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DequantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDequantizeOptions(
      _fbb);
}

inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::MaximumMinimumOptionsT> _o = std::unique_ptr<tflite::MaximumMinimumOptionsT>(new MaximumMinimumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumMinimumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMaximumMinimumOptions(
      _fbb);
}

inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::TileOptionsT> _o = std::unique_ptr<tflite::TileOptionsT>(new TileOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TileOptions::UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TileOptions> TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTileOptions(
      _fbb);
}

inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ArgMaxOptionsT> _o = std::unique_ptr<tflite::ArgMaxOptionsT>(new ArgMaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; }
}

inline flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMaxOptions(
      _fbb,
      _output_type);
}

inline ArgMinOptionsT *ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ArgMinOptionsT> _o = std::unique_ptr<tflite::ArgMinOptionsT>(new ArgMinOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; }
}

inline flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMinOptions(
      _fbb,
      _output_type);
}

inline GreaterOptionsT *GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::GreaterOptionsT> _o = std::unique_ptr<tflite::GreaterOptionsT>(new GreaterOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterOptions(
      _fbb);
}

inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::GreaterEqualOptionsT> _o = std::unique_ptr<tflite::GreaterEqualOptionsT>(new GreaterEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterEqualOptions(
      _fbb);
}

inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LessOptionsT> _o = std::unique_ptr<tflite::LessOptionsT>(new LessOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessOptions::UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessOptions> LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessOptions(
      _fbb);
}

inline LessEqualOptionsT *LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LessEqualOptionsT> _o = std::unique_ptr<tflite::LessEqualOptionsT>(new LessEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessEqualOptions(
      _fbb);
}

inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::NegOptionsT> _o = std::unique_ptr<tflite::NegOptionsT>(new NegOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NegOptions::UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NegOptions> NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNegOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNegOptions(
      _fbb);
}

inline SelectOptionsT *SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SelectOptionsT> _o = std::unique_ptr<tflite::SelectOptionsT>(new SelectOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectOptions> SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectOptions(
      _fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SliceOptionsT> _o = std::unique_ptr<tflite::SliceOptionsT>(new SliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SliceOptions> SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSliceOptions(
      _fbb);
}

inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::TransposeConvOptionsT> _o = std::unique_ptr<tflite::TransposeConvOptionsT>(new TransposeConvOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
}

inline flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeConvOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  return tflite::CreateTransposeConvOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h);
}

inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ExpandDimsOptionsT> _o = std::unique_ptr<tflite::ExpandDimsOptionsT>(new ExpandDimsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpandDimsOptions(
      _fbb);
}

inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SparseToDenseOptionsT> _o = std::unique_ptr<tflite::SparseToDenseOptionsT>(new SparseToDenseOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = validate_indices(); _o->validate_indices = _e; }
}

inline flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _validate_indices = _o->validate_indices;
  return tflite::CreateSparseToDenseOptions(
      _fbb,
      _validate_indices);
}

inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::EqualOptionsT> _o = std::unique_ptr<tflite::EqualOptionsT>(new EqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EqualOptions> EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateEqualOptions(
      _fbb);
}

inline NotEqualOptionsT *NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::NotEqualOptionsT> _o = std::unique_ptr<tflite::NotEqualOptionsT>(new NotEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNotEqualOptions(
      _fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ShapeOptionsT> _o = std::unique_ptr<tflite::ShapeOptionsT>(new ShapeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_type(); _o->out_type = _e; }
}

inline flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_type = _o->out_type;
  return tflite::CreateShapeOptions(
      _fbb,
      _out_type);
}

inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::PowOptionsT> _o = std::unique_ptr<tflite::PowOptionsT>(new PowOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowOptions::UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PowOptions> PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePowOptions(
      _fbb);
}

inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::FakeQuantOptionsT> _o = std::unique_ptr<tflite::FakeQuantOptionsT>(new FakeQuantOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = num_bits(); _o->num_bits = _e; }
  { auto _e = narrow_range(); _o->narrow_range = _e; }
}

inline flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return tflite::CreateFakeQuantOptions(
      _fbb,
      _min,
      _max,
      _num_bits,
      _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::PackOptionsT> _o = std::unique_ptr<tflite::PackOptionsT>(new PackOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PackOptions::UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values_count(); _o->values_count = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<PackOptions> PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values_count = _o->values_count;
  auto _axis = _o->axis;
  return tflite::CreatePackOptions(
      _fbb,
      _values_count,
      _axis);
}

inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LogicalOrOptionsT> _o = std::unique_ptr<tflite::LogicalOrOptionsT>(new LogicalOrOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalOrOptions(
      _fbb);
}

inline OneHotOptionsT *OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::OneHotOptionsT> _o = std::unique_ptr<tflite::OneHotOptionsT>(new OneHotOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return tflite::CreateOneHotOptions(
      _fbb,
      _axis);
}

inline AbsOptionsT *AbsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::AbsOptionsT> _o = std::unique_ptr<tflite::AbsOptionsT>(new AbsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsOptions> AbsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAbsOptions(
      _fbb);
}

inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LogicalAndOptionsT> _o = std::unique_ptr<tflite::LogicalAndOptionsT>(new LogicalAndOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalAndOptions(
      _fbb);
}

inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LogicalNotOptionsT> _o = std::unique_ptr<tflite::LogicalNotOptionsT>(new LogicalNotOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalNotOptions(
      _fbb);
}

inline UnpackOptionsT *UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::UnpackOptionsT> _o = std::unique_ptr<tflite::UnpackOptionsT>(new UnpackOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnpackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _axis = _o->axis;
  return tflite::CreateUnpackOptions(
      _fbb,
      _num,
      _axis);
}

inline FloorDivOptionsT *FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::FloorDivOptionsT> _o = std::unique_ptr<tflite::FloorDivOptionsT>(new FloorDivOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorDivOptions(
      _fbb);
}

inline SquareOptionsT *SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SquareOptionsT> _o = std::unique_ptr<tflite::SquareOptionsT>(new SquareOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquareOptions> SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquareOptions(
      _fbb);
}

inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ZerosLikeOptionsT> _o = std::unique_ptr<tflite::ZerosLikeOptionsT>(new ZerosLikeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateZerosLikeOptions(
      _fbb);
}

inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::FillOptionsT> _o = std::unique_ptr<tflite::FillOptionsT>(new FillOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FillOptions::UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FillOptions> FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFillOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFillOptions(
      _fbb);
}

inline FloorModOptionsT *FloorModOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::FloorModOptionsT> _o = std::unique_ptr<tflite::FloorModOptionsT>(new FloorModOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorModOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorModOptions(
      _fbb);
}

inline RangeOptionsT *RangeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::RangeOptionsT> _o = std::unique_ptr<tflite::RangeOptionsT>(new RangeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RangeOptions> RangeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRangeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRangeOptions(
      _fbb);
}

inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::LeakyReluOptionsT> _o = std::unique_ptr<tflite::LeakyReluOptionsT>(new LeakyReluOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return tflite::CreateLeakyReluOptions(
      _fbb,
      _alpha);
}

inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SquaredDifferenceOptionsT> _o = std::unique_ptr<tflite::SquaredDifferenceOptionsT>(new SquaredDifferenceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquaredDifferenceOptions(
      _fbb);
}

inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::MirrorPadOptionsT> _o = std::unique_ptr<tflite::MirrorPadOptionsT>(new MirrorPadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMirrorPadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MirrorPadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return tflite::CreateMirrorPadOptions(
      _fbb,
      _mode);
}

inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::OperatorCodeT> _o = std::unique_ptr<tflite::OperatorCodeT>(new OperatorCodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = builtin_code(); _o->builtin_code = _e; }
  { auto _e = custom_code(); if (_e) _o->custom_code = _e->str(); }
  { auto _e = version(); _o->version = _e; }
}

inline flatbuffers::Offset<OperatorCode> OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorCodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _builtin_code = _o->builtin_code;
  auto _custom_code = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
  auto _version = _o->version;
  return tflite::CreateOperatorCode(
      _fbb,
      _builtin_code,
      _custom_code,
      _version);
}

inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::OperatorT> _o = std::unique_ptr<tflite::OperatorT>(new OperatorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Operator::UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opcode_index(); _o->opcode_index = _e; }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }
  { auto _e = builtin_options_type(); _o->builtin_options.type = _e; }
  { auto _e = builtin_options(); if (_e) _o->builtin_options.value = tflite::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver); }
  { auto _e = custom_options(); if (_e) { _o->custom_options.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->custom_options[_i] = _e->Get(_i); } } }
  { auto _e = custom_options_format(); _o->custom_options_format = _e; }
  { auto _e = mutating_variable_inputs(); if (_e) { _o->mutating_variable_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0; } } }
}

inline flatbuffers::Offset<Operator> Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opcode_index = _o->opcode_index;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _builtin_options_type = _o->builtin_options.type;
  auto _builtin_options = _o->builtin_options.Pack(_fbb);
  auto _custom_options = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
  auto _custom_options_format = _o->custom_options_format;
  auto _mutating_variable_inputs = _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
  return tflite::CreateOperator(
      _fbb,
      _opcode_index,
      _inputs,
      _outputs,
      _builtin_options_type,
      _builtin_options,
      _custom_options,
      _custom_options_format,
      _mutating_variable_inputs);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::SubGraphT> _o = std::unique_ptr<tflite::SubGraphT>(new SubGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }
  { auto _e = operators(); if (_e) { _o->operators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _operators = _o->operators.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>> (_o->operators.size(), [](size_t i, _VectorArgs *__va) { return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return tflite::CreateSubGraph(
      _fbb,
      _tensors,
      _inputs,
      _outputs,
      _operators,
      _name);
}

inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::BufferT> _o = std::unique_ptr<tflite::BufferT>(new BufferT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return tflite::CreateBuffer(
      _fbb,
      _data);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ModelT> _o = std::unique_ptr<tflite::ModelT>(new ModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
  { auto _e = operator_codes(); if (_e) { _o->operator_codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = metadata_buffer(); if (_e) { _o->metadata_buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata_buffer[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _operator_codes = _o->operator_codes.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>> (_o->operator_codes.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
  return tflite::CreateModel(
      _fbb,
      _version,
      _operator_codes,
      _subgraphs,
      _description,
      _buffers,
      _metadata_buffer);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(
        verifier,  values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantizationT *>(value);
      return CreateCustomQuantization(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline QuantizationDetailsUnion::QuantizationDetailsUnion(const QuantizationDetailsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      value = new tflite::CustomQuantizationT(*reinterpret_cast<tflite::CustomQuantizationT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void QuantizationDetailsUnion::Reset() {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<tflite::CustomQuantizationT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = QuantizationDetails_NONE;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptionsT *>(value);
      return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value);
      return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value);
      return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value);
      return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptionsT *>(value);
      return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptionsT *>(value);
      return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptionsT *>(value);
      return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value);
      return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptionsT *>(value);
      return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptionsT *>(value);
      return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptionsT *>(value);
      return CreateAddOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptionsT *>(value);
      return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value);
      return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptionsT *>(value);
      return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value);
      return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptionsT *>(value);
      return CreateCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptionsT *>(value);
      return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptionsT *>(value);
      return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value);
      return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value);
      return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptionsT *>(value);
      return CreateMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptionsT *>(value);
      return CreatePadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptionsT *>(value);
      return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value);
      return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value);
      return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptionsT *>(value);
      return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptionsT *>(value);
      return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptionsT *>(value);
      return CreateSubOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptionsT *>(value);
      return CreateDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptionsT *>(value);
      return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value);
      return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptionsT *>(value);
      return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptionsT *>(value);
      return CreateExpOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2OptionsT *>(value);
      return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptionsT *>(value);
      return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value);
      return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptionsT *>(value);
      return CreateCastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptionsT *>(value);
      return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value);
      return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptionsT *>(value);
      return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptionsT *>(value);
      return CreateLessOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptionsT *>(value);
      return CreateNegOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2OptionsT *>(value);
      return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptionsT *>(value);
      return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value);
      return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptionsT *>(value);
      return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptionsT *>(value);
      return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptionsT *>(value);
      return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptionsT *>(value);
      return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value);
      return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptionsT *>(value);
      return CreateTileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value);
      return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptionsT *>(value);
      return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptionsT *>(value);
      return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptionsT *>(value);
      return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptionsT *>(value);
      return CreatePowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptionsT *>(value);
      return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptionsT *>(value);
      return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptionsT *>(value);
      return CreatePackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptionsT *>(value);
      return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptionsT *>(value);
      return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptionsT *>(value);
      return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptionsT *>(value);
      return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptionsT *>(value);
      return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptionsT *>(value);
      return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptionsT *>(value);
      return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value);
      return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptionsT *>(value);
      return CreateFillOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value);
      return CreateBidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value);
      return CreateBidirectionalSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
      return CreateUnidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptionsT *>(value);
      return CreateFloorModOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptionsT *>(value);
      return CreateRangeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value);
      return CreateResizeNearestNeighborOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptionsT *>(value);
      return CreateLeakyReluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value);
      return CreateSquaredDifferenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptionsT *>(value);
      return CreateMirrorPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptionsT *>(value);
      return CreateAbsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptionsT *>(value);
      return CreateSplitVOptions(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      value = new tflite::Conv2DOptionsT(*reinterpret_cast<tflite::Conv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      value = new tflite::DepthwiseConv2DOptionsT(*reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      value = new tflite::ConcatEmbeddingsOptionsT(*reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      value = new tflite::LSHProjectionOptionsT(*reinterpret_cast<tflite::LSHProjectionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      value = new tflite::Pool2DOptionsT(*reinterpret_cast<tflite::Pool2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      value = new tflite::SVDFOptionsT(*reinterpret_cast<tflite::SVDFOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RNNOptions: {
      value = new tflite::RNNOptionsT(*reinterpret_cast<tflite::RNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      value = new tflite::FullyConnectedOptionsT(*reinterpret_cast<tflite::FullyConnectedOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      value = new tflite::SoftmaxOptionsT(*reinterpret_cast<tflite::SoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      value = new tflite::ConcatenationOptionsT(*reinterpret_cast<tflite::ConcatenationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddOptions: {
      value = new tflite::AddOptionsT(*reinterpret_cast<tflite::AddOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      value = new tflite::L2NormOptionsT(*reinterpret_cast<tflite::L2NormOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      value = new tflite::LocalResponseNormalizationOptionsT(*reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      value = new tflite::LSTMOptionsT(*reinterpret_cast<tflite::LSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      value = new tflite::ResizeBilinearOptionsT(*reinterpret_cast<tflite::ResizeBilinearOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOptions: {
      value = new tflite::CallOptionsT(*reinterpret_cast<tflite::CallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      value = new tflite::ReshapeOptionsT(*reinterpret_cast<tflite::ReshapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      value = new tflite::SkipGramOptionsT(*reinterpret_cast<tflite::SkipGramOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      value = new tflite::SpaceToDepthOptionsT(*reinterpret_cast<tflite::SpaceToDepthOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      value = new tflite::EmbeddingLookupSparseOptionsT(*reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MulOptions: {
      value = new tflite::MulOptionsT(*reinterpret_cast<tflite::MulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadOptions: {
      value = new tflite::PadOptionsT(*reinterpret_cast<tflite::PadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherOptions: {
      value = new tflite::GatherOptionsT(*reinterpret_cast<tflite::GatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      value = new tflite::BatchToSpaceNDOptionsT(*reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      value = new tflite::SpaceToBatchNDOptionsT(*reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      value = new tflite::TransposeOptionsT(*reinterpret_cast<tflite::TransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      value = new tflite::ReducerOptionsT(*reinterpret_cast<tflite::ReducerOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SubOptions: {
      value = new tflite::SubOptionsT(*reinterpret_cast<tflite::SubOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DivOptions: {
      value = new tflite::DivOptionsT(*reinterpret_cast<tflite::DivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      value = new tflite::SqueezeOptionsT(*reinterpret_cast<tflite::SqueezeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      value = new tflite::SequenceRNNOptionsT(*reinterpret_cast<tflite::SequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      value = new tflite::StridedSliceOptionsT(*reinterpret_cast<tflite::StridedSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpOptions: {
      value = new tflite::ExpOptionsT(*reinterpret_cast<tflite::ExpOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      value = new tflite::TopKV2OptionsT(*reinterpret_cast<tflite::TopKV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitOptions: {
      value = new tflite::SplitOptionsT(*reinterpret_cast<tflite::SplitOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      value = new tflite::LogSoftmaxOptionsT(*reinterpret_cast<tflite::LogSoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CastOptions: {
      value = new tflite::CastOptionsT(*reinterpret_cast<tflite::CastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      value = new tflite::DequantizeOptionsT(*reinterpret_cast<tflite::DequantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      value = new tflite::MaximumMinimumOptionsT(*reinterpret_cast<tflite::MaximumMinimumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      value = new tflite::ArgMaxOptionsT(*reinterpret_cast<tflite::ArgMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessOptions: {
      value = new tflite::LessOptionsT(*reinterpret_cast<tflite::LessOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NegOptions: {
      value = new tflite::NegOptionsT(*reinterpret_cast<tflite::NegOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadV2Options: {
      value = new tflite::PadV2OptionsT(*reinterpret_cast<tflite::PadV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      value = new tflite::GreaterOptionsT(*reinterpret_cast<tflite::GreaterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      value = new tflite::GreaterEqualOptionsT(*reinterpret_cast<tflite::GreaterEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      value = new tflite::LessEqualOptionsT(*reinterpret_cast<tflite::LessEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectOptions: {
      value = new tflite::SelectOptionsT(*reinterpret_cast<tflite::SelectOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SliceOptions: {
      value = new tflite::SliceOptionsT(*reinterpret_cast<tflite::SliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      value = new tflite::TransposeConvOptionsT(*reinterpret_cast<tflite::TransposeConvOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      value = new tflite::SparseToDenseOptionsT(*reinterpret_cast<tflite::SparseToDenseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TileOptions: {
      value = new tflite::TileOptionsT(*reinterpret_cast<tflite::TileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      value = new tflite::ExpandDimsOptionsT(*reinterpret_cast<tflite::ExpandDimsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EqualOptions: {
      value = new tflite::EqualOptionsT(*reinterpret_cast<tflite::EqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      value = new tflite::NotEqualOptionsT(*reinterpret_cast<tflite::NotEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      value = new tflite::ShapeOptionsT(*reinterpret_cast<tflite::ShapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PowOptions: {
      value = new tflite::PowOptionsT(*reinterpret_cast<tflite::PowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      value = new tflite::ArgMinOptionsT(*reinterpret_cast<tflite::ArgMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      value = new tflite::FakeQuantOptionsT(*reinterpret_cast<tflite::FakeQuantOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PackOptions: {
      value = new tflite::PackOptionsT(*reinterpret_cast<tflite::PackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      value = new tflite::LogicalOrOptionsT(*reinterpret_cast<tflite::LogicalOrOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      value = new tflite::OneHotOptionsT(*reinterpret_cast<tflite::OneHotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      value = new tflite::LogicalAndOptionsT(*reinterpret_cast<tflite::LogicalAndOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      value = new tflite::LogicalNotOptionsT(*reinterpret_cast<tflite::LogicalNotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      value = new tflite::UnpackOptionsT(*reinterpret_cast<tflite::UnpackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      value = new tflite::FloorDivOptionsT(*reinterpret_cast<tflite::FloorDivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquareOptions: {
      value = new tflite::SquareOptionsT(*reinterpret_cast<tflite::SquareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      value = new tflite::ZerosLikeOptionsT(*reinterpret_cast<tflite::ZerosLikeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FillOptions: {
      value = new tflite::FillOptionsT(*reinterpret_cast<tflite::FillOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      value = new tflite::BidirectionalSequenceLSTMOptionsT(*reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      value = new tflite::BidirectionalSequenceRNNOptionsT(*reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      value = new tflite::UnidirectionalSequenceLSTMOptionsT(*reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      value = new tflite::FloorModOptionsT(*reinterpret_cast<tflite::FloorModOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RangeOptions: {
      value = new tflite::RangeOptionsT(*reinterpret_cast<tflite::RangeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      value = new tflite::ResizeNearestNeighborOptionsT(*reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      value = new tflite::LeakyReluOptionsT(*reinterpret_cast<tflite::LeakyReluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      value = new tflite::SquaredDifferenceOptionsT(*reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      value = new tflite::MirrorPadOptionsT(*reinterpret_cast<tflite::MirrorPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AbsOptions: {
      value = new tflite::AbsOptionsT(*reinterpret_cast<tflite::AbsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      value = new tflite::SplitVOptionsT(*reinterpret_cast<tflite::SplitVOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptionsUnion::Reset() {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<tflite::Conv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<tflite::LSHProjectionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<tflite::Pool2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<tflite::SVDFOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<tflite::RNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<tflite::FullyConnectedOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<tflite::SoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<tflite::ConcatenationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<tflite::AddOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<tflite::L2NormOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<tflite::LSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<tflite::CallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<tflite::ReshapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<tflite::SkipGramOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<tflite::MulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<tflite::PadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<tflite::GatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<tflite::TransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<tflite::ReducerOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<tflite::SubOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<tflite::DivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<tflite::SqueezeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<tflite::SequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<tflite::StridedSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<tflite::ExpOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<tflite::TopKV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<tflite::SplitOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<tflite::CastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<tflite::DequantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<tflite::ArgMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<tflite::LessOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<tflite::NegOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<tflite::PadV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<tflite::GreaterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<tflite::GreaterEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<tflite::LessEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<tflite::SelectOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<tflite::SliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<tflite::TransposeConvOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<tflite::SparseToDenseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<tflite::TileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<tflite::ExpandDimsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<tflite::EqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<tflite::NotEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<tflite::ShapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<tflite::PowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<tflite::ArgMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<tflite::FakeQuantOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<tflite::PackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalOrOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<tflite::OneHotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalAndOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalNotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<tflite::UnpackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<tflite::FloorDivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<tflite::SquareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<tflite::ZerosLikeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<tflite::FillOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<tflite::FloorModOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<tflite::RangeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<tflite::LeakyReluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<tflite::MirrorPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<tflite::AbsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<tflite::SplitVOptionsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BuiltinOptions_NONE;
}

inline const tflite::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline Model *GetMutableModel(void *buf) {
  return flatbuffers::GetMutableRoot<Model>(buf);
}

inline const char *ModelIdentifier() {
  return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "tflite";
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<tflite::ModelT> UnPackModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::ModelT> UnPackSizePrefixedModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
